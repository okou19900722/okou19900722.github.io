{"pageProps":{"slug":"3.8.4/vertx-core/groovy","title":"Vert.x Core Manual","toc":"<div id=\"toc\" class=\"toc\">\n<div id=\"toctitle\">Table of Contents</div>\n<ul class=\"sectlevel1\">\n<li><a href=\"#_are_you_fluent\">Are you fluent?</a></li>\n<li><a href=\"#_dont_call_us_well_call_you\">Don&#8217;t call us, we&#8217;ll call you.</a></li>\n<li><a href=\"#_dont_block_me\">Don&#8217;t block me!</a></li>\n<li><a href=\"#_reactor_and_multi_reactor\">Reactor and Multi-Reactor</a></li>\n<li><a href=\"#golden_rule\">The Golden Rule - Don&#8217;t Block the Event Loop</a></li>\n<li><a href=\"#blocking_code\">Running blocking code</a></li>\n<li><a href=\"#_async_coordination\">Async coordination</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_concurrent_composition\">Concurrent composition</a></li>\n<li><a href=\"#_sequential_composition\">Sequential composition</a></li>\n</ul>\n</li>\n<li><a href=\"#_verticles\">Verticles</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_verticle_types\">Verticle Types</a></li>\n<li><a href=\"#_standard_verticles\">Standard verticles</a></li>\n<li><a href=\"#worker_verticles\">Worker verticles</a></li>\n<li><a href=\"#_deploying_verticles_programmatically\">Deploying verticles programmatically</a></li>\n<li><a href=\"#_rules_for_mapping_a_verticle_name_to_a_verticle_factory\">Rules for mapping a verticle name to a verticle factory</a></li>\n<li><a href=\"#_how_are_verticle_factories_located\">How are Verticle Factories located?</a></li>\n<li><a href=\"#_waiting_for_deployment_to_complete\">Waiting for deployment to complete</a></li>\n<li><a href=\"#_undeploying_verticle_deployments\">Undeploying verticle deployments</a></li>\n<li><a href=\"#_specifying_number_of_verticle_instances\">Specifying number of verticle instances</a></li>\n<li><a href=\"#_verticle_isolation_groups\">Verticle Isolation Groups</a></li>\n<li><a href=\"#_high_availability\">High Availability</a></li>\n<li><a href=\"#_running_verticles_from_the_command_line\">Running Verticles from the command line</a></li>\n<li><a href=\"#_causing_vert_x_to_exit\">Causing Vert.x to exit</a></li>\n<li><a href=\"#_the_context_object\">The Context object</a></li>\n<li><a href=\"#_executing_periodic_and_delayed_actions\">Executing periodic and delayed actions</a></li>\n<li><a href=\"#_verticle_worker_pool\">Verticle worker pool</a></li>\n</ul>\n</li>\n<li><a href=\"#_thread_safety\">Thread safety</a></li>\n<li><a href=\"#_metrics_spi\">Metrics SPI</a></li>\n<li><a href=\"#_osgi\">OSGi</a></li>\n<li><a href=\"#_the_vertx_command_line\">The 'vertx' command line</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_run_verticles\">Run verticles</a></li>\n<li><a href=\"#_executing_a_vert_x_application_packaged_as_a_fat_jar\">Executing a Vert.x application packaged as a fat jar</a></li>\n<li><a href=\"#_displaying_version_of_vert_x\">Displaying version of Vert.x</a></li>\n<li><a href=\"#_other_commands\">Other commands</a></li>\n<li><a href=\"#_live_redeploy\">Live Redeploy</a></li>\n</ul>\n</li>\n<li><a href=\"#_cluster_managers\">Cluster Managers</a></li>\n<li><a href=\"#_logging\">Logging</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_configuring_jul_logging\">Configuring JUL logging</a></li>\n<li><a href=\"#_using_another_logging_framework\">Using another logging framework</a></li>\n<li><a href=\"#netty-logging\">Netty logging</a></li>\n<li><a href=\"#_troubleshooting\">Troubleshooting</a></li>\n</ul>\n</li>\n<li><a href=\"#_high_availability_and_fail_over\">High Availability and Fail-Over</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_automatic_failover\">Automatic failover</a></li>\n<li><a href=\"#_ha_groups\">HA groups</a></li>\n<li><a href=\"#_dealing_with_network_partitions_quora\">Dealing with network partitions - Quora</a></li>\n</ul>\n</li>\n<li><a href=\"#_native_transports\">Native transports</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_native_linux_transport\">Native Linux Transport</a></li>\n<li><a href=\"#_native_bsd_transport\">Native BSD Transport</a></li>\n<li><a href=\"#_domain_sockets\">Domain sockets</a></li>\n</ul>\n</li>\n<li><a href=\"#_security_notes\">Security notes</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_web_applications\">Web applications</a></li>\n<li><a href=\"#_clustered_event_bus_traffic\">Clustered event bus traffic</a></li>\n<li><a href=\"#_standard_security_best_practices\">Standard security best practices</a></li>\n</ul>\n</li>\n<li><a href=\"#_vert_x_command_line_interface_api\">Vert.x Command Line Interface API</a></li>\n<li><a href=\"#_the_vert_x_launcher\">The vert.x Launcher</a>\n<ul class=\"sectlevel2\">\n<li><a href=\"#_extending_the_vert_x_launcher\">Extending the vert.x Launcher</a></li>\n<li><a href=\"#_using_the_launcher_in_fat_jars\">Using the Launcher in fat jars</a></li>\n<li><a href=\"#_sub_classing_the_launcher\">Sub-classing the Launcher</a></li>\n<li><a href=\"#_launcher_and_exit_code\">Launcher and exit code</a></li>\n</ul>\n</li>\n<li><a href=\"#_configuring_vert_x_cache\">Configuring Vert.x cache</a></li>\n</ul>\n</div>","contents":"<h1>Vert.x Core Manual</h1>\n\n<div id=\"preamble\">\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>At the heart of Vert.x is a set of Java APIs that we call <strong>Vert.x Core</strong></p>\n</div>\n<div class=\"paragraph\">\n<p><a href=\"https://github.com/eclipse/vert.x\">Repository</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x core provides functionality for things like:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Writing TCP clients and servers</p>\n</li>\n<li>\n<p>Writing HTTP clients and servers including support for WebSockets</p>\n</li>\n<li>\n<p>The Event bus</p>\n</li>\n<li>\n<p>Shared data - local maps and clustered distributed maps</p>\n</li>\n<li>\n<p>Periodic and delayed actions</p>\n</li>\n<li>\n<p>Deploying and undeploying Verticles</p>\n</li>\n<li>\n<p>Datagram Sockets</p>\n</li>\n<li>\n<p>DNS client</p>\n</li>\n<li>\n<p>File system access</p>\n</li>\n<li>\n<p>High availability</p>\n</li>\n<li>\n<p>Native transports</p>\n</li>\n<li>\n<p>Clustering</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>The functionality in core is fairly low level - you won&#8217;t find stuff like database access, authorisation or high level\nweb functionality here - that kind of stuff you&#8217;ll find in <strong>Vert.x ext</strong> (extensions).</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x core is small and lightweight. You just use the parts you want. It&#8217;s also entirely embeddable in your\nexisting applications - we don&#8217;t force you to structure your applications in a special way just so you can use\nVert.x.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can use core from any of the other languages that Vert.x supports. But here&#8217;a a cool bit - we don&#8217;t force\nyou to use the Java API directly from, say, JavaScript or Ruby - after all, different languages have different conventions\nand idioms, and it would be odd to force Java idioms on Ruby developers (for example).\nInstead, we automatically generate an <strong>idiomatic</strong> equivalent of the core Java APIs for each language.</p>\n</div>\n<div class=\"paragraph\">\n<p>From now on we&#8217;ll just use the word <strong>core</strong> to refer to Vert.x core.</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::override/dependencies.adoc[]</p>\n</div>\n<div class=\"paragraph\">\n<p>Let&#8217;s discuss the different concepts and features in core.</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::override/in-the-beginning.adoc[]</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_are_you_fluent\"><a class=\"anchor\" href=\"#_are_you_fluent\"></a>Are you fluent?</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>You may have noticed that in the previous examples a <strong>fluent</strong> API was used.</p>\n</div>\n<div class=\"paragraph\">\n<p>A fluent API is where multiple methods calls can be chained together. For example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">request.response().putHeader(<span class=\"hljs-string\">\"Content-Type\"</span>, <span class=\"hljs-string\">\"text/plain\"</span>).write(<span class=\"hljs-string\">\"some text\"</span>).end()</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This is a common pattern throughout Vert.x APIs, so get used to it.</p>\n</div>\n<div class=\"paragraph\">\n<p>Chaining calls like this allows you to write code that&#8217;s a little bit less verbose. Of course, if you don&#8217;t\nlike the fluent approach <strong>we don&#8217;t force you</strong> to do it that way, you can happily ignore it if you prefer and write\nyour code like this:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> response = request.response()\nresponse.putHeader(<span class=\"hljs-string\">\"Content-Type\"</span>, <span class=\"hljs-string\">\"text/plain\"</span>)\nresponse.write(<span class=\"hljs-string\">\"some text\"</span>)\nresponse.end()</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_dont_call_us_well_call_you\"><a class=\"anchor\" href=\"#_dont_call_us_well_call_you\"></a>Don&#8217;t call us, we&#8217;ll call you.</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The Vert.x APIs are largely <em>event driven</em>. This means that when things happen in Vert.x that you are interested in,\nVert.x will call you by sending you events.</p>\n</div>\n<div class=\"paragraph\">\n<p>Some example events are:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>a timer has fired</p>\n</li>\n<li>\n<p>some data has arrived on a socket,</p>\n</li>\n<li>\n<p>some data has been read from disk</p>\n</li>\n<li>\n<p>an exception has occurred</p>\n</li>\n<li>\n<p>an HTTP server has received a request</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>You handle events by providing <em>handlers</em> to the Vert.x APIs. For example to receive a timer event every second you\nwould do:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">vertx.setPeriodic(<span class=\"hljs-number\">1000</span>, { id -&gt;\n  <span class=\"hljs-comment\">// This handler will get called every second</span>\n  println(<span class=\"hljs-string\">\"timer fired!\"</span>)\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Or to receive an HTTP request:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-comment\">// Respond to each http request with \"Hello World\"</span>\nserver.requestHandler({ request -&gt;\n  <span class=\"hljs-comment\">// This handler will be called every time an HTTP request is received at the server</span>\n  request.response().end(<span class=\"hljs-string\">\"hello world!\"</span>)\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Some time later when Vert.x has an event to pass to your handler Vert.x will call it <strong>asynchronously</strong>.</p>\n</div>\n<div class=\"paragraph\">\n<p>This leads us to some important concepts in Vert.x:</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_dont_block_me\"><a class=\"anchor\" href=\"#_dont_block_me\"></a>Don&#8217;t block me!</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>With very few exceptions (i.e. some file system operations ending in 'Sync'), none of the APIs in Vert.x block the calling thread.</p>\n</div>\n<div class=\"paragraph\">\n<p>If a result can be provided immediately, it will be returned immediately, otherwise you will usually provide a handler\nto receive events some time later.</p>\n</div>\n<div class=\"paragraph\">\n<p>Because none of the Vert.x APIs block threads that means you can use Vert.x to handle a lot of concurrency using\njust a small number of threads.</p>\n</div>\n<div class=\"paragraph\">\n<p>With a conventional blocking API the calling thread might block when:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Reading data from a socket</p>\n</li>\n<li>\n<p>Writing data to disk</p>\n</li>\n<li>\n<p>Sending a message to a recipient and waiting for a reply.</p>\n</li>\n<li>\n<p>&#8230;&#8203; Many other situations</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>In all the above cases, when your thread is waiting for a result it can&#8217;t do anything else - it&#8217;s effectively useless.</p>\n</div>\n<div class=\"paragraph\">\n<p>This means that if you want a lot of concurrency using blocking APIs then you need a lot of threads to prevent your\napplication grinding to a halt.</p>\n</div>\n<div class=\"paragraph\">\n<p>Threads have overhead in terms of the memory they require (e.g. for their stack) and in context switching.</p>\n</div>\n<div class=\"paragraph\">\n<p>For the levels of concurrency required in many modern applications, a blocking approach just doesn&#8217;t scale.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_reactor_and_multi_reactor\"><a class=\"anchor\" href=\"#_reactor_and_multi_reactor\"></a>Reactor and Multi-Reactor</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>We mentioned before that Vert.x APIs are event driven - Vert.x passes events to handlers when they are available.</p>\n</div>\n<div class=\"paragraph\">\n<p>In most cases Vert.x calls your handlers using a thread called an <strong>event loop</strong>.</p>\n</div>\n<div class=\"paragraph\">\n<p>As nothing in Vert.x or your application blocks, the event loop can merrily run around delivering events to different handlers in succession\nas they arrive.</p>\n</div>\n<div class=\"paragraph\">\n<p>Because nothing blocks, an event loop can potentially deliver huge amounts of events in a short amount of time.\nFor example a single event loop can handle many thousands of HTTP requests very quickly.</p>\n</div>\n<div class=\"paragraph\">\n<p>We call this the <a href=\"http://en.wikipedia.org/wiki/Reactor_pattern\">Reactor Pattern</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>You may have heard of this before - for example Node.js implements this pattern.</p>\n</div>\n<div class=\"paragraph\">\n<p>In a standard reactor implementation there is a <strong>single event loop</strong> thread which runs around in a loop delivering all\nevents to all handlers as they arrive.</p>\n</div>\n<div class=\"paragraph\">\n<p>The trouble with a single thread is it can only run on a single core at any one time, so if you want your single threaded\nreactor application (e.g. your Node.js application) to scale over your multi-core server you have to start up and\nmanage many different processes.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x works differently here. Instead of a single event loop, each Vertx instance maintains <strong>several event loops</strong>.\nBy default we choose the number based on the number of available cores on the machine, but this can be overridden.</p>\n</div>\n<div class=\"paragraph\">\n<p>This means a single Vertx process can scale across your server, unlike Node.js.</p>\n</div>\n<div class=\"paragraph\">\n<p>We call this pattern the <strong>Multi-Reactor Pattern</strong> to distinguish it from the single threaded reactor pattern.</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nEven though a Vertx instance maintains multiple event loops, any particular handler will never be executed\nconcurrently, and in most cases (with the exception of <a href=\"#worker_verticles\">worker verticles</a>) will always be called\nusing the <strong>exact same event loop</strong>.\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"golden_rule\"><a class=\"anchor\" href=\"#golden_rule\"></a>The Golden Rule - Don&#8217;t Block the Event Loop</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>We already know that the Vert.x APIs are non blocking and won&#8217;t block the event loop, but that&#8217;s not much help if\nyou block the event loop <strong>yourself</strong> in a handler.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you do that, then that event loop will not be able to do anything else while it&#8217;s blocked. If you block all of the\nevent loops in Vertx instance then your application will grind to a complete halt!</p>\n</div>\n<div class=\"paragraph\">\n<p>So don&#8217;t do it! <strong>You have been warned</strong>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Examples of blocking include:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Thread.sleep()</p>\n</li>\n<li>\n<p>Waiting on a lock</p>\n</li>\n<li>\n<p>Waiting on a mutex or monitor (e.g. synchronized section)</p>\n</li>\n<li>\n<p>Doing a long lived database operation and waiting for a result</p>\n</li>\n<li>\n<p>Doing a complex calculation that takes some significant time.</p>\n</li>\n<li>\n<p>Spinning in a loop</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>If any of the above stop the event loop from doing anything else for a <strong>significant amount of time</strong> then you should\ngo immediately to the naughty step, and await further instructions.</p>\n</div>\n<div class=\"paragraph\">\n<p>So&#8230;&#8203; what is a <strong>significant amount of time</strong>?</p>\n</div>\n<div class=\"paragraph\">\n<p>How long is a piece of string? It really depends on your application and the amount of concurrency you require.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you have a single event loop, and you want to handle 10000 http requests per second, then it&#8217;s clear that each request\ncan&#8217;t take more than 0.1 ms to process, so you can&#8217;t block for any more time than that.</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>The maths is not hard and shall be left as an exercise for the reader.</strong></p>\n</div>\n<div class=\"paragraph\">\n<p>If your application is not responsive it might be a sign that you are blocking an event loop somewhere. To help\nyou diagnose such issues, Vert.x will automatically log warnings if it detects an event loop hasn&#8217;t returned for\nsome time. If you see warnings like these in your logs, then you should investigate.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>Thread vertx-eventloop-thread-3 has been blocked for 20458 ms</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x will also provide stack traces to pinpoint exactly where the blocking is occurring.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you want to turn off these warnings or change the settings, you can do that in the\n<code><a href=\"../../apidocs/io/vertx/core/VertxOptions.html\">VertxOptions</a></code> object before creating the Vertx object.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"blocking_code\"><a class=\"anchor\" href=\"#blocking_code\"></a>Running blocking code</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>In a perfect world, there will be no war or hunger, all APIs will be written asynchronously and bunny rabbits will\nskip hand-in-hand with baby lambs across sunny green meadows.</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>But&#8230;&#8203; the real world is not like that. (Have you watched the news lately?)</strong></p>\n</div>\n<div class=\"paragraph\">\n<p>Fact is, many, if not most libraries, especially in the JVM ecosystem have synchronous APIs and many of the methods are\nlikely to block. A good example is the JDBC API - it&#8217;s inherently synchronous, and no matter how hard it tries, Vert.x\ncannot sprinkle magic pixie dust on it to make it asynchronous.</p>\n</div>\n<div class=\"paragraph\">\n<p>We&#8217;re not going to rewrite everything to be asynchronous overnight so we need to provide you a way to use \"traditional\"\nblocking APIs safely within a Vert.x application.</p>\n</div>\n<div class=\"paragraph\">\n<p>As discussed before, you can&#8217;t call blocking operations directly from an event loop, as that would prevent it\nfrom doing any other useful work. So how can you do this?</p>\n</div>\n<div class=\"paragraph\">\n<p>It&#8217;s done by calling <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#executeBlocking-io.vertx.core.Handler-boolean-io.vertx.core.Handler-\">executeBlocking</a></code> specifying both the blocking code to execute and a\nresult handler to be called back asynchronous when the blocking code has been executed.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">vertx.executeBlocking({ promise -&gt;\n  <span class=\"hljs-comment\">// Call some blocking API that takes a significant amount of time to return</span>\n  <span class=\"hljs-keyword\">def</span> result = someAPI.blockingMethod(<span class=\"hljs-string\">\"hello\"</span>)\n  promise.complete(result)\n}, { res -&gt;\n  println(<span class=\"hljs-string\">\"The result is: ${res.result()}\"</span>)\n})</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Warning</div>\n</td>\n<td class=\"content\">\nBlocking code should block for a reasonable amount of time (i.e no more than a few seconds). Long blocking operations\n        or polling operations (i.e a thread that spin in a loop polling events in a blocking fashion) are precluded.\n        When the blocking operation lasts more than the 10 seconds, a message will be printed on the console by the\n        blocked thread checker. Long blocking operations should use a dedicated thread managed by the application,\n        which can interact with verticles using the event-bus or <code><a href=\"../../apidocs/io/vertx/core/Context.html#runOnContext-io.vertx.core.Handler-\">runOnContext</a></code>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>By default, if executeBlocking is called several times from the same context (e.g. the same verticle instance) then\nthe different executeBlocking are executed <em>serially</em> (i.e. one after another).</p>\n</div>\n<div class=\"paragraph\">\n<p>If you don&#8217;t care about ordering you can call <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#executeBlocking-io.vertx.core.Handler-boolean-io.vertx.core.Handler-\">executeBlocking</a></code>\nspecifying <code>false</code> as the argument to <code>ordered</code>. In this case any executeBlocking may be executed in parallel\non the worker pool.</p>\n</div>\n<div class=\"paragraph\">\n<p>An alternative way to run blocking code is to use a <a href=\"#worker_verticles\">worker verticle</a></p>\n</div>\n<div class=\"paragraph\">\n<p>A worker verticle is always executed with a thread from the worker pool.</p>\n</div>\n<div class=\"paragraph\">\n<p>By default blocking code is executed on the Vert.x worker pool, configured with <code><a href=\"../../apidocs/io/vertx/core/VertxOptions.html#setWorkerPoolSize-int-\">setWorkerPoolSize</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Additional pools can be created for different purposes:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> executor = vertx.createSharedWorkerExecutor(<span class=\"hljs-string\">\"my-worker-pool\"</span>)\nexecutor.executeBlocking({ promise -&gt;\n  <span class=\"hljs-comment\">// Call some blocking API that takes a significant amount of time to return</span>\n  <span class=\"hljs-keyword\">def</span> result = someAPI.blockingMethod(<span class=\"hljs-string\">\"hello\"</span>)\n  promise.complete(result)\n}, { res -&gt;\n  println(<span class=\"hljs-string\">\"The result is: ${res.result()}\"</span>)\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The worker executor must be closed when it&#8217;s not necessary anymore:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">executor.close()</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When several workers are created with the same name, they will share the same pool. The worker pool is destroyed\nwhen all the worker executors using it are closed.</p>\n</div>\n<div class=\"paragraph\">\n<p>When an executor is created in a Verticle, Vert.x will close it automatically for you when the Verticle\nis undeployed.</p>\n</div>\n<div class=\"paragraph\">\n<p>Worker executors can be configured when created:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-comment\">//</span>\n<span class=\"hljs-comment\">// 10 threads max</span>\n<span class=\"hljs-keyword\">def</span> poolSize = <span class=\"hljs-number\">10</span>\n\n<span class=\"hljs-comment\">// 2 minutes</span>\n<span class=\"hljs-keyword\">def</span> maxExecuteTime = <span class=\"hljs-number\">2</span>\n<span class=\"hljs-keyword\">def</span> maxExecuteTimeUnit = TimeUnit.MINUTES\n\n<span class=\"hljs-keyword\">def</span> executor = vertx.createSharedWorkerExecutor(<span class=\"hljs-string\">\"my-worker-pool\"</span>, poolSize, maxExecuteTime, maxExecuteTimeUnit)</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nthe configuration is set when the worker pool is created\n</td>\n</tr>\n</table>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_async_coordination\"><a class=\"anchor\" href=\"#_async_coordination\"></a>Async coordination</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Coordination of multiple asynchronous results can be achieved with Vert.x <code><a href=\"../../apidocs/io/vertx/core/Future.html\">futures</a></code>. It\nsupports concurrent composition (run several async operations in parallel) and sequential composition\n(chain async operations).</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_concurrent_composition\"><a class=\"anchor\" href=\"#_concurrent_composition\"></a>Concurrent composition</h3>\n<div class=\"paragraph\">\n<p><code><a href=\"../../apidocs/io/vertx/core/CompositeFuture.html#all-io.vertx.core.Future-io.vertx.core.Future-\">CompositeFuture.all</a></code> takes several futures arguments (up to 6) and returns a future that is\n<em>succeeded</em> when all the futures are and <em>failed</em> when at least one of the futures is failed:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> httpServerFuture = Future.future({ promise -&gt;\n  httpServer.listen(promise)\n})\n\n<span class=\"hljs-keyword\">def</span> netServerFuture = Future.future({ promise -&gt;\n  netServer.listen(promise)\n})\n\nCompositeFuture.all(httpServerFuture, netServerFuture).setHandler({ ar -&gt;\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// All servers started</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// At least one server failed</span>\n  }\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The operations run concurrently, the <code><a href=\"../../apidocs/io/vertx/core/Handler.html\">Handler</a></code> attached to the returned future is invoked upon\ncompletion of the composition. When one of the operation fails (one of the passed future is marked as a failure),\nthe resulting future is marked as failed too. When all the operations succeed, the resulting future is completed\nwith a success.</p>\n</div>\n<div class=\"paragraph\">\n<p>Alternatively, you can pass a list (potentially empty) of futures:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">CompositeFuture.all([future1, future2, future3])</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>While the <code>all</code> composition <em>waits</em> until all futures are successful (or one fails), the <code>any</code> composition\n<em>waits</em> for the first succeeded future. <code><a href=\"../../apidocs/io/vertx/core/CompositeFuture.html#any-io.vertx.core.Future-io.vertx.core.Future-\">CompositeFuture.any</a></code> takes several futures\narguments (up to 6) and returns a future that is succeeded when one of the futures is, and failed when\nall the futures are failed:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">CompositeFuture.any(future1, future2).setHandler({ ar -&gt;\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// At least one is succeeded</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// All failed</span>\n  }\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>A list of futures can be used also:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">CompositeFuture.any([f1, f2, f3])</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code>join</code> composition <em>waits</em> until all futures are completed, either with a success or a failure.\n<code><a href=\"../../apidocs/io/vertx/core/CompositeFuture.html#join-io.vertx.core.Future-io.vertx.core.Future-\">CompositeFuture.join</a></code> takes several futures arguments (up to 6) and returns a future that is\nsucceeded when all the futures are succeeded, and failed when all the futures are completed and at least one of\nthem is failed:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">CompositeFuture.join(future1, future2, future3).setHandler({ ar -&gt;\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// All succeeded</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    <span class=\"hljs-comment\">// All completed and at least one failed</span>\n  }\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>A list of futures can be used also:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">CompositeFuture.join([future1, future2, future3])</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_sequential_composition\"><a class=\"anchor\" href=\"#_sequential_composition\"></a>Sequential composition</h3>\n<div class=\"paragraph\">\n<p>While <code>all</code> and <code>any</code> are implementing concurrent composition, <code><a href=\"../../apidocs/io/vertx/core/Future.html#compose-io.vertx.core.Handler-io.vertx.core.Future-\">compose</a></code> can be used\nfor chaining futures (so sequential composition).</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> fs = vertx.fileSystem()\n\n<span class=\"hljs-keyword\">def</span> fut1 = Future.future({ promise -&gt;\n  fs.createFile(<span class=\"hljs-string\">\"/foo\"</span>, promise)\n})\n\n<span class=\"hljs-keyword\">def</span> startFuture = fut1.compose({ v -&gt;\n  <span class=\"hljs-comment\">// When the file is created (fut1), execute this:</span>\n  <span class=\"hljs-keyword\">return</span> Future.future({ promise -&gt;\n    fs.writeFile(<span class=\"hljs-string\">\"/foo\"</span>, Buffer.buffer(), promise)\n  })\n}).compose({ v -&gt;\n  <span class=\"hljs-comment\">// When the file is written (fut2), execute this:</span>\n  <span class=\"hljs-keyword\">return</span> Future.future({ promise -&gt;\n    fs.move(<span class=\"hljs-string\">\"/foo\"</span>, <span class=\"hljs-string\">\"/bar\"</span>, promise)\n  })\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In this example, 3 operations are chained:</p>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>a file is created (<code>fut1</code>)</p>\n</li>\n<li>\n<p>something is written in the file (<code>fut2</code>)</p>\n</li>\n<li>\n<p>the file is moved (<code>startFuture</code>)</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>When these 3 steps are successful, the final future (<code>startFuture</code>) is succeeded. However, if one\nof the steps fails, the final future is failed.</p>\n</div>\n<div class=\"paragraph\">\n<p>This example uses:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/Future.html#compose-java.util.function.Function-\">compose</a></code>: when the current future completes,\nrun the given function, that returns a future. When this returned future completes, it completes the composition.</p>\n</li>\n<li>\n<p><code><a href=\"../../apidocs/io/vertx/core/Future.html#compose-io.vertx.core.Handler-io.vertx.core.Future-\">compose</a></code>: when the current future\ncompletes, run the given handler that completes the given <code>future</code> (next).</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>In this second case, the <code><a href=\"../../apidocs/io/vertx/core/Handler.html\">Handler</a></code> should complete the <code>next</code> future to report its success or\nfailure.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_verticles\"><a class=\"anchor\" href=\"#_verticles\"></a>Verticles</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x comes with a simple, scalable, <em>actor-like</em> deployment and concurrency model out of the box that\nyou can use to save you writing your own.</p>\n</div>\n<div class=\"paragraph\">\n<p><strong>This model is entirely optional and Vert.x does not force you to create your applications in this way if you don&#8217;t\nwant to.</strong>.</p>\n</div>\n<div class=\"paragraph\">\n<p>The model does not claim to be a strict actor-model implementation, but it does share similarities especially\nwith respect to concurrency, scaling and deployment.</p>\n</div>\n<div class=\"paragraph\">\n<p>To use this model, you write your code as set of <strong>verticles</strong>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Verticles are chunks of code that get deployed and run by Vert.x. A Vert.x instance maintains N event loop threads\n(where N by default is core*2) by default. Verticles can be written in any of the languages that Vert.x supports\nand a single application can include verticles written in multiple languages.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can think of a verticle as a bit like an actor in the <a href=\"http://en.wikipedia.org/wiki/Actor_model\">Actor Model</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>An application would typically be composed of many verticle instances running in the same Vert.x instance at the same\ntime. The different verticle instances communicate with each other by sending messages on the <a href=\"#event_bus\">event bus</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::override/verticles.adoc[]</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_verticle_types\"><a class=\"anchor\" href=\"#_verticle_types\"></a>Verticle Types</h3>\n<div class=\"paragraph\">\n<p>There are three different types of verticles:</p>\n</div>\n<div class=\"dlist\">\n<dl>\n<dt class=\"hdlist1\">Standard Verticles</dt>\n<dd>\n<p>These are the most common and useful type - they are always executed using an event loop thread.\nWe&#8217;ll discuss this more in the next section.</p>\n</dd>\n<dt class=\"hdlist1\">Worker Verticles</dt>\n<dd>\n<p>These run using a thread from the worker pool. An instance is never executed concurrently by more\nthan one thread.</p>\n</dd>\n<dt class=\"hdlist1\">Multi-threaded worker verticles</dt>\n<dd>\n<p>These run using a thread from the worker pool. An instance can be executed concurrently by more\nthan one thread.</p>\n</dd>\n</dl>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_standard_verticles\"><a class=\"anchor\" href=\"#_standard_verticles\"></a>Standard verticles</h3>\n<div class=\"paragraph\">\n<p>Standard verticles are assigned an event loop thread when they are created and the start method is called with that\nevent loop. When you call any other methods that takes a handler on a core API from an event loop then Vert.x\nwill guarantee that those handlers, when called, will be executed on the same event loop.</p>\n</div>\n<div class=\"paragraph\">\n<p>This means we can guarantee that all the code in your verticle instance is always executed on the same event loop (as\nlong as you don&#8217;t create your own threads and call it!).</p>\n</div>\n<div class=\"paragraph\">\n<p>This means you can write all the code in your application as single threaded and let Vert.x worry about the threading\nand scaling. No more worrying about synchronized and volatile any more, and you also avoid many other cases of race conditions\nand deadlock so prevalent when doing hand-rolled 'traditional' multi-threaded application development.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"worker_verticles\"><a class=\"anchor\" href=\"#worker_verticles\"></a>Worker verticles</h3>\n<div class=\"paragraph\">\n<p>A worker verticle is just like a standard verticle but it&#8217;s executed using a thread from the Vert.x worker thread pool,\nrather than using an event loop.</p>\n</div>\n<div class=\"paragraph\">\n<p>Worker verticles are designed for calling blocking code, as they won&#8217;t block any event loops.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you don&#8217;t want to use a worker verticle to run blocking code, you can also run <a href=\"#blocking_code\">inline blocking code</a>\ndirectly while on an event loop.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you want to deploy a verticle as a worker verticle you do that with <code><a href=\"../../apidocs/io/vertx/core/DeploymentOptions.html#setWorker-boolean-\">setWorker</a></code>.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> options = [\n<span class=\"hljs-symbol\">  worker:</span><span class=\"hljs-literal\">true</span>\n]\nvertx.deployVerticle(<span class=\"hljs-string\">\"com.mycompany.MyOrderProcessorVerticle\"</span>, options)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Worker verticle instances are never executed concurrently by Vert.x by more than one thread, but can executed by\ndifferent threads at different times.</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_multi_threaded_worker_verticles\"><a class=\"anchor\" href=\"#_multi_threaded_worker_verticles\"></a>Multi-threaded worker verticles</h4>\n<div class=\"paragraph\">\n<p>A multi-threaded worker verticle is just like a normal worker verticle but it <strong>can</strong> be executed concurrently by\ndifferent threads.</p>\n</div>\n<div class=\"admonitionblock caution\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Caution</div>\n</td>\n<td class=\"content\">\nMulti-threaded worker verticles are an advanced feature and most applications will have no need for them.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Because of the concurrency in these verticles you have to be very careful to keep the verticle in a consistent state\nusing standard Java techniques for multi-threaded programming.</p>\n</div>\n<div class=\"paragraph\">\n<p>Multi-threaded worker verticles were designed and are intended for the sole use of consuming simultaneously <code>EventBus</code> messages in a blocking fashion.</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Warning</div>\n</td>\n<td class=\"content\">\nVert.x clients and servers (TCP, HTTP, &#8230;&#8203;etc) cannot be created in a multi-threaded worker verticle.\nShould you incidentally try, an exception will be thrown.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Essentially, multi-threaded worker verticles simply avoid the user from deploying as much instances of a worker verticle as the number of threads in a worker pool.\nSo you could for example provide a worker pool name/size in <code><a href=\"../../apidocs/io/vertx/core/DeploymentOptions.html\">DeploymentOptions</a></code> and set the number of instances accordingly:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> options = [\n<span class=\"hljs-symbol\">  worker:</span><span class=\"hljs-literal\">true</span>,\n<span class=\"hljs-symbol\">  instances:</span><span class=\"hljs-number\">5</span>,\n<span class=\"hljs-symbol\">  workerPoolName:</span><span class=\"hljs-string\">\"the-specific-pool\"</span>,\n<span class=\"hljs-symbol\">  workerPoolSize:</span><span class=\"hljs-number\">5</span>\n]\nvertx.deployVerticle(<span class=\"hljs-string\">\"com.mycompany.MyOrderProcessorVerticle\"</span>, options)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Alternatively, you could create a regular verticle and wrap you blocking code with multiple <code>executeBlocking</code> with the <code>ordered</code> flag set to <code>false</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">vertx.eventBus().consumer(<span class=\"hljs-string\">\"foo\"</span>, { msg -&gt;\n  vertx.executeBlocking({ promise -&gt;\n    <span class=\"hljs-comment\">// Invoke blocking code with received message data</span>\n    promise.complete(someresult)\n  }, <span class=\"hljs-literal\">false</span>, { ar -&gt;\n    <span class=\"hljs-comment\">// Handle result, e.g. reply to the message</span>\n  })\n})</code></pre>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_deploying_verticles_programmatically\"><a class=\"anchor\" href=\"#_deploying_verticles_programmatically\"></a>Deploying verticles programmatically</h3>\n<div class=\"paragraph\">\n<p>You can deploy a verticle using one of the <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#deployVerticle-io.vertx.core.Verticle-\">deployVerticle</a></code> method, specifying a verticle\nname or you can pass in a verticle instance you have already created yourself.</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nDeploying Verticle <strong>instances</strong> is Java only.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">def myVerticle = <span class=\"hljs-keyword\">new</span> examples.CoreExamples.MyVerticle()\nvertx.deployVerticle(myVerticle)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can also deploy verticles by specifying the verticle <strong>name</strong>.</p>\n</div>\n<div class=\"paragraph\">\n<p>The verticle name is used to look up the specific <code><a href=\"../../apidocs/io/vertx/core/spi/VerticleFactory.html\">VerticleFactory</a></code> that will be used to\ninstantiate the actual verticle instance(s).</p>\n</div>\n<div class=\"paragraph\">\n<p>Different verticle factories are available for instantiating verticles in different languages and for various other\nreasons such as loading services and getting verticles from Maven at run-time.</p>\n</div>\n<div class=\"paragraph\">\n<p>This allows you to deploy verticles written in any language from any other language that Vert.x supports.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s an example of deploying some different types of verticles:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-comment\">// Deploy a Java verticle - the name is the fully qualified class name of the verticle class</span>\nvertx.deployVerticle(<span class=\"hljs-string\">\"com.mycompany.MyOrderProcessorVerticle\"</span>)\n\n<span class=\"hljs-comment\">// Deploy a JavaScript verticle</span>\nvertx.deployVerticle(<span class=\"hljs-string\">\"verticles/myverticle.js\"</span>)\n\n<span class=\"hljs-comment\">// Deploy a Ruby verticle verticle</span>\nvertx.deployVerticle(<span class=\"hljs-string\">\"verticles/my_verticle.rb\"</span>)</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_rules_for_mapping_a_verticle_name_to_a_verticle_factory\"><a class=\"anchor\" href=\"#_rules_for_mapping_a_verticle_name_to_a_verticle_factory\"></a>Rules for mapping a verticle name to a verticle factory</h3>\n<div class=\"paragraph\">\n<p>When deploying verticle(s) using a name, the name is used to select the actual verticle factory that will instantiate\nthe verticle(s).</p>\n</div>\n<div class=\"paragraph\">\n<p>Verticle names can have a prefix - which is a string followed by a colon, which if present will be used to look-up the factory, e.g.</p>\n</div>\n<div class=\"paragraph\">\n<p>js:foo.js // Use the JavaScript verticle factory\ngroovy:com.mycompany.SomeGroovyCompiledVerticle // Use the Groovy verticle factory\nservice:com.mycompany:myorderservice // Uses the service verticle factory</p>\n</div>\n<div class=\"paragraph\">\n<p>If no prefix is present, Vert.x will look for a suffix and use that to lookup the factory, e.g.</p>\n</div>\n<div class=\"paragraph\">\n<p>foo.js // Will also use the JavaScript verticle factory\nSomeScript.groovy // Will use the Groovy verticle factory</p>\n</div>\n<div class=\"paragraph\">\n<p>If no prefix or suffix is present, Vert.x will assume it&#8217;s a Java fully qualified class name (FQCN) and try\nand instantiate that.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_how_are_verticle_factories_located\"><a class=\"anchor\" href=\"#_how_are_verticle_factories_located\"></a>How are Verticle Factories located?</h3>\n<div class=\"paragraph\">\n<p>Most Verticle factories are loaded from the classpath and registered at Vert.x startup.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can also programmatically register and unregister verticle factories using <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#registerVerticleFactory-io.vertx.core.spi.VerticleFactory-\">registerVerticleFactory</a></code>\nand <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#unregisterVerticleFactory-io.vertx.core.spi.VerticleFactory-\">unregisterVerticleFactory</a></code> if you wish.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_waiting_for_deployment_to_complete\"><a class=\"anchor\" href=\"#_waiting_for_deployment_to_complete\"></a>Waiting for deployment to complete</h3>\n<div class=\"paragraph\">\n<p>Verticle deployment is asynchronous and may complete some time after the call to deploy has returned.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you want to be notified when deployment is complete you can deploy specifying a completion handler:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">vertx.deployVerticle(<span class=\"hljs-string\">\"com.mycompany.MyOrderProcessorVerticle\"</span>, { res -&gt;\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    println(<span class=\"hljs-string\">\"Deployment id is: ${res.result()}\"</span>)\n  } <span class=\"hljs-keyword\">else</span> {\n    println(<span class=\"hljs-string\">\"Deployment failed!\"</span>)\n  }\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The completion handler will be passed a result containing the deployment ID string, if deployment succeeded.</p>\n</div>\n<div class=\"paragraph\">\n<p>This deployment ID can be used later if you want to undeploy the deployment.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_undeploying_verticle_deployments\"><a class=\"anchor\" href=\"#_undeploying_verticle_deployments\"></a>Undeploying verticle deployments</h3>\n<div class=\"paragraph\">\n<p>Deployments can be undeployed with <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#undeploy-java.lang.String-\">undeploy</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Un-deployment is itself asynchronous so if you want to be notified when un-deployment is complete you can deploy specifying a completion handler:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">vertx.undeploy(deploymentID, { res -&gt;\n  <span class=\"hljs-keyword\">if</span> (res.succeeded()) {\n    println(<span class=\"hljs-string\">\"Undeployed ok\"</span>)\n  } <span class=\"hljs-keyword\">else</span> {\n    println(<span class=\"hljs-string\">\"Undeploy failed!\"</span>)\n  }\n})</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_specifying_number_of_verticle_instances\"><a class=\"anchor\" href=\"#_specifying_number_of_verticle_instances\"></a>Specifying number of verticle instances</h3>\n<div class=\"paragraph\">\n<p>When deploying a verticle using a verticle name, you can specify the number of verticle instances that you\nwant to deploy:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> options = [\n<span class=\"hljs-symbol\">  instances:</span><span class=\"hljs-number\">16</span>\n]\nvertx.deployVerticle(<span class=\"hljs-string\">\"com.mycompany.MyOrderProcessorVerticle\"</span>, options)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>This is useful for scaling easily across multiple cores. For example you might have a web-server verticle to deploy\nand multiple cores on your machine, so you want to deploy multiple instances to utilise all the cores.</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::override/verticle-configuration.adoc[]</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_verticle_isolation_groups\"><a class=\"anchor\" href=\"#_verticle_isolation_groups\"></a>Verticle Isolation Groups</h3>\n<div class=\"paragraph\">\n<p>By default, Vert.x has a <em>flat classpath</em>. I.e, when Vert.x deploys verticles it does so with the current classloader -\nit doesn&#8217;t create a new one. In the majority of cases this is the simplest, clearest, and sanest thing to do.</p>\n</div>\n<div class=\"paragraph\">\n<p>However, in some cases you may want to deploy a verticle so the classes of that verticle are isolated from others in\nyour application.</p>\n</div>\n<div class=\"paragraph\">\n<p>This might be the case, for example, if you want to deploy two different versions of a verticle with the same class name\nin the same Vert.x instance, or if you have two different verticles which use different versions of the same jar library.</p>\n</div>\n<div class=\"paragraph\">\n<p>When using an isolation group you provide a list of the class names that you want isolated using\n<code><a href=\"../../apidocs/io/vertx/core/DeploymentOptions.html#setIsolatedClasses-java.util.List-\">setIsolatedClasses</a></code>-  an entry can be a fully qualified\nclassname such as <code>com.mycompany.myproject.engine.MyClass</code> or it can be a wildcard which will match any classes in a package and any\nsub-packages, e.g. <code>com.mycompany.myproject.*</code> would match any classes in the package <code>com.mycompany.myproject</code> or\nany sub-packages.</p>\n</div>\n<div class=\"paragraph\">\n<p>Please note that <em>only</em> the classes that match will be isolated - any other classes will be loaded by the current\nclass loader.</p>\n</div>\n<div class=\"paragraph\">\n<p>Extra classpath entries can also be provided with <code><a href=\"../../apidocs/io/vertx/core/DeploymentOptions.html#setExtraClasspath-java.util.List-\">setExtraClasspath</a></code> so if\nyou want to load classes or resources that aren&#8217;t already present on the main classpath you can add this.</p>\n</div>\n<div class=\"admonitionblock warning\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Warning</div>\n</td>\n<td class=\"content\">\nUse this feature with caution. Class-loaders can be a can of worms, and can make debugging difficult, amongst\nother things.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>Here&#8217;s an example of using an isolation group to isolate a verticle deployment.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> options = [\n<span class=\"hljs-symbol\">  isolationGroup:</span><span class=\"hljs-string\">\"mygroup\"</span>\n]\noptions.isolatedClasses = [<span class=\"hljs-string\">\"com.mycompany.myverticle.*\"</span>, <span class=\"hljs-string\">\"com.mycompany.somepkg.SomeClass\"</span>, <span class=\"hljs-string\">\"org.somelibrary.*\"</span>]\nvertx.deployVerticle(<span class=\"hljs-string\">\"com.mycompany.myverticle.VerticleClass\"</span>, options)</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_high_availability\"><a class=\"anchor\" href=\"#_high_availability\"></a>High Availability</h3>\n<div class=\"paragraph\">\n<p>Verticles can be deployed with High Availability (HA) enabled. In that context, when a verticle is deployed on\na vert.x instance that dies abruptly, the verticle is redeployed on another vert.x instance from the cluster.</p>\n</div>\n<div class=\"paragraph\">\n<p>To run an verticle with the high availability enabled, just append the <code>-ha</code> switch:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-verticle.js -ha</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When enabling high availability, no need to add <code>-cluster</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>More details about the high availability feature and configuration in the <a href=\"#_high_availability_and_fail_over\">High Availability and Fail-Over</a>\n section.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_running_verticles_from_the_command_line\"><a class=\"anchor\" href=\"#_running_verticles_from_the_command_line\"></a>Running Verticles from the command line</h3>\n<div class=\"paragraph\">\n<p>You can use Vert.x directly in your Maven or Gradle projects in the normal way by adding a dependency to the Vert.x\ncore library and hacking from there.</p>\n</div>\n<div class=\"paragraph\">\n<p>However you can also run Vert.x verticles directly from the command line if you wish.</p>\n</div>\n<div class=\"paragraph\">\n<p>To do this you need to download and install a Vert.x distribution, and add the <code>bin</code> directory of the installation\nto your <code>PATH</code> environment variable. Also make sure you have a Java 8 JDK on your <code>PATH</code>.</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nThe JDK is required to support on the fly compilation of Java code.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>You can now run verticles by using the <code>vertx run</code> command. Here are some examples:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre># Run a JavaScript verticle\nvertx run my_verticle.js\n\n# Run a Ruby verticle\nvertx run a_n_other_verticle.rb\n\n# Run a Groovy script verticle, clustered\nvertx run FooVerticle.groovy -cluster</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can even run Java source verticles without compiling them first!</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>vertx run SomeJavaSourceFile.java</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x will compile the Java source file on the fly before running it. This is really useful for quickly\nprototyping verticles and great for demos. No need to set-up a Maven or Gradle build first to get going!</p>\n</div>\n<div class=\"paragraph\">\n<p>For full information on the various options available when executing <code>vertx</code> on the command line,\ntype <code>vertx</code> at the command line.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_causing_vert_x_to_exit\"><a class=\"anchor\" href=\"#_causing_vert_x_to_exit\"></a>Causing Vert.x to exit</h3>\n<div class=\"paragraph\">\n<p>Threads maintained by Vert.x instances are not daemon threads so they will prevent the JVM from exiting.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you are embedding Vert.x and you have finished with it, you can call <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#close--\">close</a></code> to close it\ndown.</p>\n</div>\n<div class=\"paragraph\">\n<p>This will shut-down all internal thread pools and close other resources, and will allow the JVM to exit.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_the_context_object\"><a class=\"anchor\" href=\"#_the_context_object\"></a>The Context object</h3>\n<div class=\"paragraph\">\n<p>When Vert.x provides an event to a handler or calls the start or stop methods of a\n<code><a href=\"../../apidocs/io/vertx/core/Verticle.html\">Verticle</a></code>, the execution is associated with a <code>Context</code>. Usually a context is an\n<strong>event-loop context</strong> and is tied to a specific event loop thread. So executions for that context always occur\non that exact same event loop thread. In the case of worker verticles and running inline blocking code a\nworker context will be associated with the execution which will use a thread from the worker thread pool.</p>\n</div>\n<div class=\"paragraph\">\n<p>To retrieve the context, use the <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#getOrCreateContext--\">getOrCreateContext</a></code> method:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> context = vertx.getOrCreateContext()</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If the current thread has a context associated with it, it reuses the context object. If not a new instance of\ncontext is created. You can test the <em>type</em> of context you have retrieved:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> context = vertx.getOrCreateContext()\n<span class=\"hljs-keyword\">if</span> (context.isEventLoopContext()) {\n  println(<span class=\"hljs-string\">\"Context attached to Event Loop\"</span>)\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (context.isWorkerContext()) {\n  println(<span class=\"hljs-string\">\"Context attached to Worker Thread\"</span>)\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (context.isMultiThreadedWorkerContext()) {\n  println(<span class=\"hljs-string\">\"Context attached to Worker Thread - multi threaded worker\"</span>)\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> (!Context.isOnVertxThread()) {\n  println(<span class=\"hljs-string\">\"Context not attached to a thread managed by vert.x\"</span>)\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When you have retrieved the context object, you can run code in this context asynchronously. In other words,\nyou submit a task that will be eventually run in the same context, but later:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">vertx.getOrCreateContext().runOnContext({ v -&gt;\n  println(<span class=\"hljs-string\">\"This will be executed asynchronously in the same context\"</span>)\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When several handlers run in the same context, they may want to share data. The context object offers methods to\nstore and retrieve data shared in the context. For instance, it lets you pass data to some action run with\n<code><a href=\"../../apidocs/io/vertx/core/Context.html#runOnContext-io.vertx.core.Handler-\">runOnContext</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> context = vertx.getOrCreateContext()\ncontext.put(<span class=\"hljs-string\">\"data\"</span>, <span class=\"hljs-string\">\"hello\"</span>)\ncontext.runOnContext({ v -&gt;\n  <span class=\"hljs-keyword\">def</span> hello = context.get(<span class=\"hljs-string\">\"data\"</span>)\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The context object also let you access verticle configuration using the <code><a href=\"../../apidocs/io/vertx/core/Context.html#config--\">config</a></code>\nmethod. Check the <a href=\"#Passing configuration to a verticle\">[Passing configuration to a verticle]</a> section for more details about this configuration.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_executing_periodic_and_delayed_actions\"><a class=\"anchor\" href=\"#_executing_periodic_and_delayed_actions\"></a>Executing periodic and delayed actions</h3>\n<div class=\"paragraph\">\n<p>It&#8217;s very common in Vert.x to want to perform an action after a delay, or periodically.</p>\n</div>\n<div class=\"paragraph\">\n<p>In standard verticles you can&#8217;t just make the thread sleep to introduce a delay, as that will block the event loop thread.</p>\n</div>\n<div class=\"paragraph\">\n<p>Instead you use Vert.x timers. Timers can be <strong>one-shot</strong> or <strong>periodic</strong>. We&#8217;ll discuss both</p>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_one_shot_timers\"><a class=\"anchor\" href=\"#_one_shot_timers\"></a>One-shot Timers</h4>\n<div class=\"paragraph\">\n<p>A one shot timer calls an event handler after a certain delay, expressed in milliseconds.</p>\n</div>\n<div class=\"paragraph\">\n<p>To set a timer to fire once you use <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#setTimer-long-io.vertx.core.Handler-\">setTimer</a></code> method passing in the delay and a handler</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> timerID = vertx.setTimer(<span class=\"hljs-number\">1000</span>, { id -&gt;\n  println(<span class=\"hljs-string\">\"And one second later this is printed\"</span>)\n})\n\nprintln(<span class=\"hljs-string\">\"First this is printed\"</span>)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The return value is a unique timer id which can later be used to cancel the timer. The handler is also passed the timer id.</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_periodic_timers\"><a class=\"anchor\" href=\"#_periodic_timers\"></a>Periodic Timers</h4>\n<div class=\"paragraph\">\n<p>You can also set a timer to fire periodically by using <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#setPeriodic-long-io.vertx.core.Handler-\">setPeriodic</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>There will be an initial delay equal to the period.</p>\n</div>\n<div class=\"paragraph\">\n<p>The return value of <code>setPeriodic</code> is a unique timer id (long). This can be later used if the timer needs to be cancelled.</p>\n</div>\n<div class=\"paragraph\">\n<p>The argument passed into the timer event handler is also the unique timer id:</p>\n</div>\n<div class=\"paragraph\">\n<p>Keep in mind that the timer will fire on a periodic basis. If your periodic treatment takes a long amount of time to proceed,\nyour timer events could run continuously or even worse : stack up.</p>\n</div>\n<div class=\"paragraph\">\n<p>In this case, you should consider using <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#setTimer-long-io.vertx.core.Handler-\">setTimer</a></code> instead. Once your treatment has\nfinished, you can set the next timer.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> timerID = vertx.setPeriodic(<span class=\"hljs-number\">1000</span>, { id -&gt;\n  println(<span class=\"hljs-string\">\"And every second this is printed\"</span>)\n})\n\nprintln(<span class=\"hljs-string\">\"First this is printed\"</span>)</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_cancelling_timers\"><a class=\"anchor\" href=\"#_cancelling_timers\"></a>Cancelling timers</h4>\n<div class=\"paragraph\">\n<p>To cancel a periodic timer, call <code><a href=\"../../apidocs/io/vertx/core/Vertx.html#cancelTimer-long-\">cancelTimer</a></code> specifying the timer id. For example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">vertx.cancelTimer(timerID)</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_automatic_clean_up_in_verticles\"><a class=\"anchor\" href=\"#_automatic_clean_up_in_verticles\"></a>Automatic clean-up in verticles</h4>\n<div class=\"paragraph\">\n<p>If you&#8217;re creating timers from inside verticles, those timers will be automatically closed\nwhen the verticle is undeployed.</p>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_verticle_worker_pool\"><a class=\"anchor\" href=\"#_verticle_worker_pool\"></a>Verticle worker pool</h3>\n<div class=\"paragraph\">\n<p>Verticles use the Vert.x worker pool for executing blocking actions, i.e <code><a href=\"../../apidocs/io/vertx/core/Context.html#executeBlocking-io.vertx.core.Handler-boolean-io.vertx.core.Handler-\">executeBlocking</a></code> or\nworker verticle.</p>\n</div>\n<div class=\"paragraph\">\n<p>A different worker pool can be specified in deployment options:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">vertx.deployVerticle(<span class=\"hljs-string\">\"the-verticle\"</span>, [\n<span class=\"hljs-symbol\">  workerPoolName:</span><span class=\"hljs-string\">\"the-specific-pool\"</span>\n])</code></pre>\n</div>\n</div>\n<div id=\"event_bus\" class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::eventbus.adoc[]</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::override/json.adoc[]</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::json-pointers.adoc[]</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::buffers.adoc[]</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::net.adoc[]</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::http.adoc[]</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::shareddata.adoc[]</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::filesystem.adoc[]</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::datagrams.adoc[]</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::dns.adoc[]</p>\n</div>\n<div id=\"streams\" class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::streams.adoc[]</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::parsetools.adoc[]</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_thread_safety\"><a class=\"anchor\" href=\"#_thread_safety\"></a>Thread safety</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Most Vert.x objects are safe to access from different threads. <em>However</em> performance is optimised when they are\naccessed from the same context they were created from.</p>\n</div>\n<div class=\"paragraph\">\n<p>For example if you have deployed a verticle which creates a <code><a href=\"../../apidocs/io/vertx/core/net/NetServer.html\">NetServer</a></code> which provides\n<code><a href=\"../../apidocs/io/vertx/core/net/NetSocket.html\">NetSocket</a></code> instances in it&#8217;s handler, then it&#8217;s best to always access that socket instance\nfrom the event loop of the verticle.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you stick to the standard Vert.x verticle deployment model and avoid sharing objects between verticles then this\nshould be the case without you having to think about it.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_metrics_spi\"><a class=\"anchor\" href=\"#_metrics_spi\"></a>Metrics SPI</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>By default Vert.x does not record any metrics. Instead it provides an SPI for others to implement which can be added\nto the classpath. The metrics SPI is an advanced feature which allows implementers to capture events from Vert.x in\norder to gather metrics. For more information on this, please consult the\n<code><a href=\"../../apidocs/io/vertx/core/spi/metrics/VertxMetrics.html\">API Documentation</a></code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can also specify a metrics factory programmatically if embedding Vert.x using\n<code><a href=\"../../apidocs/io/vertx/core/metrics/MetricsOptions.html#setFactory-io.vertx.core.spi.VertxMetricsFactory-\">setFactory</a></code>.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_osgi\"><a class=\"anchor\" href=\"#_osgi\"></a>OSGi</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x Core is packaged as an OSGi bundle, so can be used in any OSGi R4.2+ environment such as Apache Felix\nor Eclipse Equinox. The bundle exports <code>io.vertx.core*</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>However, the bundle has some dependencies on Jackson and Netty. To get the vert.x core bundle resolved deploy:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Jackson Annotation [2.6.0,3)</p>\n</li>\n<li>\n<p>Jackson Core [2.6.2,3)</p>\n</li>\n<li>\n<p>Jackson Databind [2.6.2,3)</p>\n</li>\n<li>\n<p>Netty Buffer [4.0.31,5)</p>\n</li>\n<li>\n<p>Netty Codec [4.0.31,5)</p>\n</li>\n<li>\n<p>Netty Codec/Socks [4.0.31,5)</p>\n</li>\n<li>\n<p>Netty Codec/Common [4.0.31,5)</p>\n</li>\n<li>\n<p>Netty Codec/Handler [4.0.31,5)</p>\n</li>\n<li>\n<p>Netty Codec/Transport [4.0.31,5)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Here is a working deployment on Apache Felix 5.2.0:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>14|Active     |    1|Jackson-annotations (2.6.0)\n15|Active     |    1|Jackson-core (2.6.2)\n16|Active     |    1|jackson-databind (2.6.2)\n18|Active     |    1|Netty/Buffer (4.0.31.Final)\n19|Active     |    1|Netty/Codec (4.0.31.Final)\n20|Active     |    1|Netty/Codec/HTTP (4.0.31.Final)\n21|Active     |    1|Netty/Codec/Socks (4.0.31.Final)\n22|Active     |    1|Netty/Common (4.0.31.Final)\n23|Active     |    1|Netty/Handler (4.0.31.Final)\n24|Active     |    1|Netty/Transport (4.0.31.Final)\n25|Active     |    1|Netty/Transport/SCTP (4.0.31.Final)\n26|Active     |    1|Vert.x Core (3.1.0)</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>On Equinox, you may want to disable the <code>ContextFinder</code> with the following framework property:\n<code>eclipse.bundle.setTCCL=false</code></p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_the_vertx_command_line\"><a class=\"anchor\" href=\"#_the_vertx_command_line\"></a>The 'vertx' command line</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The <code>vertx</code> command is used to interact with Vert.x from the command line. It&#8217;s main use is to run Vert.x verticles.\nTo do this you need to download and install a Vert.x distribution, and add the <code>bin</code> directory of the installation\nto your <code>PATH</code> environment variable. Also make sure you have a Java 8 JDK on your <code>PATH</code>.</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nThe JDK is required to support on the fly compilation of Java code.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_run_verticles\"><a class=\"anchor\" href=\"#_run_verticles\"></a>Run verticles</h3>\n<div class=\"paragraph\">\n<p>You can run raw Vert.x verticles directly from the command line using <code>vertx run</code>. Here is a couple of examples of\nthe <code>run</code> <em>command</em>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-verticle.js                                 (1)\nvertx run my-verticle.groovy                             (2)\nvertx run my-verticle.rb                                 (3)\n\nvertx run io.vertx.example.MyVerticle                    (4)\nvertx run io.vertx.example.MVerticle -cp my-verticle.jar (5)\n\nvertx run MyVerticle.java                                (6)</code></pre>\n</div>\n</div>\n<div class=\"olist arabic\">\n<ol class=\"arabic\">\n<li>\n<p>Deploys a JavaScript verticle</p>\n</li>\n<li>\n<p>Deploys a Groovy verticle</p>\n</li>\n<li>\n<p>Deploys a Ruby verticle</p>\n</li>\n<li>\n<p>Deploys an already compiled Java verticle. Classpath root is the current directory</p>\n</li>\n<li>\n<p>Deploys a verticle packaged in a Jar, the jar need to be in the classpath</p>\n</li>\n<li>\n<p>Compiles the Java source and deploys it</p>\n</li>\n</ol>\n</div>\n<div class=\"paragraph\">\n<p>As you can see in the case of Java, the name can either be the fully qualified class name of the verticle, or\nyou can specify the Java Source file directly and Vert.x compiles it for you.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can also prefix the verticle with the name of the language implementation to use. For example if the verticle is\na compiled Groovy class, you prefix it with <code>groovy:</code> so that Vert.x knows it&#8217;s a Groovy class not a Java class.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run groovy:io.vertx.example.MyGroovyVerticle</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code>vertx run</code> command can take a few optional parameters, they are:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>-options &lt;options&gt;</code> - Provides the Vert.x options.\n<code>options</code> is the name of a JSON file that represents the Vert.x options, or a JSON string. This is optional.</p>\n</li>\n<li>\n<p><code>-conf &lt;config&gt;</code> - Provides some configuration to the verticle.\n<code>config</code> is the name of a JSON file that represents the configuration for the verticle, or a JSON string. This is optional.</p>\n</li>\n<li>\n<p><code>-cp &lt;path&gt;</code> - The path on which to search for the verticle and any other resources used by the verticle. This\ndefaults to <code>.</code> (current directory). If your verticle references other scripts, classes or other resources\n(e.g. jar files) then make sure these are on this path. The path can contain multiple path entries separated by\n<code>:</code> (colon) or <code>;</code> (semi-colon) depending on the operating system. Each path entry can be an absolute or relative\npath to a directory containing scripts, or absolute or relative filenames for jar or zip files. An example path\nmight be <code>-cp classes:lib/otherscripts:jars/myjar.jar:jars/otherjar.jar</code>. Always use the path to reference any\nresources that your verticle requires. Do <strong>not</strong> put them on the system classpath as this can cause isolation\nissues between deployed verticles.</p>\n</li>\n<li>\n<p><code>-instances &lt;instances&gt;</code>  - The number of instances of the verticle to instantiate. Each verticle instance is\nstrictly single threaded so to scale your application across available cores you might want to deploy more than\none instance. If omitted a single instance will be deployed.</p>\n</li>\n<li>\n<p><code>-worker</code> - This option determines whether the verticle is a worker verticle or not.</p>\n</li>\n<li>\n<p><code>-cluster</code> -  This option determines whether the Vert.x instance will attempt to form a cluster with other Vert.x\ninstances on the network. Clustering Vert.x instances allows Vert.x to form a distributed event bus with\nother nodes. Default is <code>false</code> (not clustered).</p>\n</li>\n<li>\n<p><code>-cluster-port</code> - If the <code>cluster</code> option has also been specified then this determines which port will be bound for\ncluster communication with other Vert.x instances. Default is <code>0</code> - which means '<em>choose a free random port</em>'. You\ndon&#8217;t usually need to specify this parameter unless you really need to bind to a specific port.</p>\n</li>\n<li>\n<p><code>-cluster-host</code> - If the <code>cluster</code> option has also been specified then this determines which host address will be\nbound for cluster communication with other Vert.x instances. By default it will try and pick one from the available\ninterfaces. If you have more than one interface and you want to use a specific one, specify it here.</p>\n</li>\n<li>\n<p><code>-cluster-public-port</code> - If the <code>cluster</code> option has also been specified then this determines which port will be advertised for\ncluster communication with other Vert.x instances. Default is <code>-1</code>, which means same as <code>cluster-port</code>.</p>\n</li>\n<li>\n<p><code>-cluster-public-host</code> - If the <code>cluster</code> option has also been specified then this determines which host address will be advertised for\ncluster communication with other Vert.x instances. If not specified, Vert.x uses the value of <code>cluster-host</code>.</p>\n</li>\n<li>\n<p><code>-ha</code> - if specified the verticle will be deployed as  high availability (HA) deployment. See related section\nfor more details</p>\n</li>\n<li>\n<p><code>-quorum</code> - used in conjunction with <code>-ha</code>. It specifies the minimum number of nodes in the cluster for any <em>HA\ndeploymentIDs</em> to be active. Defaults to 0.</p>\n</li>\n<li>\n<p><code>-hagroup</code> - used in conjunction with <code>-ha</code>. It specifies the HA group this node will join. There can be\nmultiple HA groups in a cluster. Nodes will only failover to other nodes in the same group. The default value is `\n__DEFAULT__`</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>You can also set system properties using: <code>-Dkey=value</code>.</p>\n</div>\n<div class=\"paragraph\">\n<p>Here are some more examples:</p>\n</div>\n<div class=\"paragraph\">\n<p>Run a JavaScript verticle server.js with default settings</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run server.js</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Run 10 instances of a pre-compiled Java verticle specifying classpath</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run com.acme.MyVerticle -cp \"classes:lib/myjar.jar\" -instances 10</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Run 10 instances of a Java verticle by source <em>file</em></p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run MyVerticle.java -instances 10</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Run 20 instances of a ruby worker verticle</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run order_worker.rb -instances 20 -worker</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Run two JavaScript verticles on the same machine and let them cluster together with each other and any other servers\non the network</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run handler.js -cluster\nvertx run sender.js -cluster</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Run a Ruby verticle passing it some config</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my_verticle.rb -conf my_verticle.conf</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Where <code>my_verticle.conf</code> might contain something like:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-json\" data-lang=\"json\">{\n<span class=\"hljs-attr\">\"name\"</span>: <span class=\"hljs-string\">\"foo\"</span>,\n<span class=\"hljs-attr\">\"num_widgets\"</span>: <span class=\"hljs-number\">46</span>\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The config will be available inside the verticle via the core API.</p>\n</div>\n<div class=\"paragraph\">\n<p>When using the high-availability feature of vert.x you may want to create a <em>bare</em> instance of vert.x. This\ninstance does not deploy any verticles when launched, but will receive a verticle if another node of the cluster\ndies. To create a <em>bare</em> instance, launch:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx bare</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Depending on your cluster configuration, you may have to append the <code>cluster-host</code> and <code>cluster-port</code> parameters.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_executing_a_vert_x_application_packaged_as_a_fat_jar\"><a class=\"anchor\" href=\"#_executing_a_vert_x_application_packaged_as_a_fat_jar\"></a>Executing a Vert.x application packaged as a fat jar</h3>\n<div class=\"paragraph\">\n<p>A <em>fat jar</em> is an executable jar embedding its dependencies. This means you don&#8217;t have to have Vert.x pre-installed\non the machine on which you execute the jar. Like any executable Java jar it can be executed with.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>java -jar my-application-fat.jar</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>There is nothing really Vert.x specific about this, you could do this with any Java application</p>\n</div>\n<div class=\"paragraph\">\n<p>You can either create your own main class and specify that in the manifest, but it&#8217;s recommended that you write your\ncode as verticles and use the Vert.x <code><a href=\"../../apidocs/io/vertx/core/Launcher.html\">Launcher</a></code> class (<code>io.vertx.core.Launcher</code>) as your main\nclass. This is the same main class used when running Vert.x at the command line and therefore allows you to\nspecify command line arguments, such as <code>-instances</code> in order to scale your application more easily.</p>\n</div>\n<div class=\"paragraph\">\n<p>To deploy your verticle in a <em>fatjar</em> like this you must have a <em>manifest</em> with:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>Main-Class</code> set to <code>io.vertx.core.Launcher</code></p>\n</li>\n<li>\n<p><code>Main-Verticle</code> specifying the main verticle (fully qualified class name or script file name)</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>You can also provide the usual command line arguments that you would pass to <code>vertx run</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>java -jar my-verticle-fat.jar -cluster -conf myconf.json\njava -jar my-verticle-fat.jar -cluster -conf myconf.json -cp path/to/dir/conf/cluster_xml</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nPlease consult the Maven/Gradle simplest and Maven/Gradle verticle examples in the examples repository for\nexamples of building applications as fatjars.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>A fat jar executes the <code>run</code> command, by default.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_displaying_version_of_vert_x\"><a class=\"anchor\" href=\"#_displaying_version_of_vert_x\"></a>Displaying version of Vert.x</h3>\n<div class=\"paragraph\">\n<p>To display the vert.x version, just launch:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx version</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_other_commands\"><a class=\"anchor\" href=\"#_other_commands\"></a>Other commands</h3>\n<div class=\"paragraph\">\n<p>The <code>vertx</code> command line and the <code>Launcher</code> also provide other <em>commands</em> in addition to <code>run</code> and <code>version</code>:</p>\n</div>\n<div class=\"paragraph\">\n<p>You can create a <code>bare</code> instance using:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx bare\n# or\njava -jar my-verticle-fat.jar bare</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can also start an application in background using:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>java -jar my-verticle-fat.jar start --vertx-id=my-app-name</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If <code>my-app-name</code> is not set, a random id will be generated, and printed on the command prompt. You can pass <code>run</code>\noptions to the <code>start</code> command:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>java -jar my-verticle-fat.jar start —-vertx-id=my-app-name -cluster</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Once launched in background, you can stop it with the <code>stop</code> command:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>java -jar my-verticle-fat.jar stop my-app-name</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You can also list the vert.x application launched in background using:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>java -jar my-verticle-fat.jar list</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The <code>start</code>, <code>stop</code> and <code>list</code> command are also available from the <code>vertx</code> tool. The start` command supports a couple of options:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>vertx-id</code> : the application id, uses a random UUID if not set</p>\n</li>\n<li>\n<p><code>java-opts</code> : the Java Virtual Machine options, uses the <code>JAVA_OPTS</code> environment variable if not set.</p>\n</li>\n<li>\n<p><code>redirect-output</code> : redirect the spawned process output and error streams to the parent process streams.</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>If option values contain spaces, don&#8217;t forget to wrap the value between <code>\"\"</code> (double-quotes).</p>\n</div>\n<div class=\"paragraph\">\n<p>As the <code>start</code> command spawns a new process, the java options passed to the JVM are not propagated, so you <strong>must</strong>\nuse <code>java-opts</code> to configure the JVM (<code>-X</code>, <code>-D</code>&#8230;&#8203;). If you use the <code>CLASSPATH</code> environment variable, be sure it\ncontains all the required jars (vertx-core, your jars and all the dependencies).</p>\n</div>\n<div class=\"paragraph\">\n<p>The set of commands is extensible, refer to the <a href=\"#_extending_the_vert_x_launcher\">Extending the vert.x Launcher</a> section.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_live_redeploy\"><a class=\"anchor\" href=\"#_live_redeploy\"></a>Live Redeploy</h3>\n<div class=\"paragraph\">\n<p>When developing it may be convenient to automatically redeploy your application upon file changes. The <code>vertx</code>\ncommand line tool and more generally the <code><a href=\"../../apidocs/io/vertx/core/Launcher.html\">Launcher</a></code> class offers this feature. Here are some\nexamples:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run MyVerticle.groovy --redeploy=\"**&amp;#47;*.groovy\" --launcher-class=io.vertx.core.Launcher\nvertx run MyVerticle.groovy --redeploy=\"**&amp;#47;*.groovy,**&amp;#47;*.rb\"  --launcher-class=io.vertx.core.Launcher\njava io.vertx.core.Launcher run org.acme.MyVerticle --redeploy=\"**&amp;#47;*.class\"  --launcher-class=io.vertx.core\n.Launcher -cp ...</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The redeployment process is implemented as follows. First your application is launched as a background application\n(with the <code>start</code> command). On matching file changes, the process is stopped and the application is restarted.\nThis avoids leaks, as the process is restarted.</p>\n</div>\n<div class=\"paragraph\">\n<p>To enable the live redeploy, pass the <code>--redeploy</code> option to the <code>run</code> command. The <code>--redeploy</code> indicates the\nset of file to <em>watch</em>. This set can use Ant-style patterns (with <code>**</code>, <code>*</code> and <code>?</code>). You can specify\nseveral sets by separating them using a comma (<code>,</code>). Patterns are relative to the current working directory.</p>\n</div>\n<div class=\"paragraph\">\n<p>Parameters passed to the <code>run</code> command are passed to the application. Java Virtual Machine options can be\nconfigured using <code>--java-opts</code>. For instance, to pass the the <code>conf</code> parameter or a system property, you need to\nuse: <code>--java-opts=\"-conf=my-conf.json -Dkey=value\"</code></p>\n</div>\n<div class=\"paragraph\">\n<p>The <code>--launcher-class</code> option determine with with <em>main</em> class the application is launcher. It&#8217;s generally\n<code><a href=\"../../apidocs/io/vertx/core/Launcher.html\">Launcher</a></code>, but you have use you own <em>main</em>.</p>\n</div>\n<div class=\"paragraph\">\n<p>The redeploy feature can be used in your IDE:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Eclipse - create a <em>Run</em> configuration, using the <code>io.vertx.core.Launcher</code> class a <em>main class</em>. In the <em>Program\narguments</em> area (in the <em>Arguments</em> tab), write <code>run your-verticle-fully-qualified-name --redeploy=**&#47;*.java\n--launcher-class=io.vertx.core.Launcher</code>. You can also add other parameters. The redeployment works smoothly as\nEclipse incrementally compiles your files on save.</p>\n</li>\n<li>\n<p>IntelliJ - create a <em>Run</em> configuration (<em>Application</em>), set the <em>Main class</em> to <code>io.vertx.core.Launcher</code>. In\nthe Program arguments write: <code>run your-verticle-fully-qualified-name --redeploy=**&#47;*.class\n--launcher-class=io.vertx.core.Launcher</code>. To trigger the redeployment, you need to <em>make</em> the project or\nthe module explicitly (<em>Build</em> menu &#8594; <em>Make project</em>).</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>To debug your application, create your run configuration as a remote application and configure the debugger\nusing <code>--java-opts</code>. However, don&#8217;t forget to re-plug the debugger after every redeployment as a new process is\ncreated every time.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can also hook your build process in the redeploy cycle:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>java -jar target/my-fat-jar.jar --redeploy=\"**&amp;#47;*.java\" --on-redeploy=\"mvn package\"\njava -jar build/libs/my-fat-jar.jar --redeploy=\"src&amp;#47;**&amp;#47;*.java\" --on-redeploy='./gradlew shadowJar'</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The \"on-redeploy\" option specifies a command invoked after the shutdown of the application and before the\nrestart. So you can hook your build tool if it updates some runtime artifacts. For instance, you can launch <code>gulp</code>\nor <code>grunt</code> to update your resources. Don&#8217;t forget that passing parameters to your application requires the\n<code>--java-opts</code> param:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>java -jar target/my-fat-jar.jar --redeploy=\"**&amp;#47;*.java\" --on-redeploy=\"mvn package\" --java-opts=\"-Dkey=val\"\njava -jar build/libs/my-fat-jar.jar --redeploy=\"src&amp;#47;**&amp;#47;*.java\" --on-redeploy='./gradlew shadowJar' --java-opts=\"-Dkey=val\"</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>The redeploy feature also supports the following settings:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>redeploy-scan-period</code> : the file system check period (in milliseconds), 250ms by default</p>\n</li>\n<li>\n<p><code>redeploy-grace-period</code> : the amount of time (in milliseconds) to wait between 2 re-deployments, 1000ms by default</p>\n</li>\n<li>\n<p><code>redeploy-termination-period</code> : the amount of time to wait after having stopped the application (before\nlaunching user command). This is useful on Windows, where the process is not killed immediately. The time is given\nin milliseconds. 0 ms by default.</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_cluster_managers\"><a class=\"anchor\" href=\"#_cluster_managers\"></a>Cluster Managers</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>In Vert.x a cluster manager is used for various functions including:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>Discovery and group membership of Vert.x nodes in a cluster</p>\n</li>\n<li>\n<p>Maintaining cluster wide topic subscriber lists (so we know which nodes are interested in which event bus addresses)</p>\n</li>\n<li>\n<p>Distributed Map support</p>\n</li>\n<li>\n<p>Distributed Locks</p>\n</li>\n<li>\n<p>Distributed Counters</p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>Cluster managers <em>do not</em> handle the event bus inter-node transport, this is done directly by Vert.x with TCP connections.</p>\n</div>\n<div class=\"paragraph\">\n<p>The default cluster manager used in the Vert.x distributions is one that uses <a href=\"http://hazelcast.com\">Hazelcast</a> but this\ncan be easily replaced by a different implementation as Vert.x cluster managers are pluggable.</p>\n</div>\n<div class=\"paragraph\">\n<p>A cluster manager must implement the interface <code><a href=\"../../apidocs/io/vertx/core/spi/cluster/ClusterManager.html\">ClusterManager</a></code>. Vert.x locates\ncluster managers at run-time by using the Java\n<a href=\"https://docs.oracle.com/javase/8/docs/api/java/util/ServiceLoader.html\">Service Loader</a> functionality to locate\ninstances of <code><a href=\"../../apidocs/io/vertx/core/spi/cluster/ClusterManager.html\">ClusterManager</a></code> on the classpath.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you are using Vert.x at the command line and you want to use clustering you should make sure the <code>lib</code> directory\nof the Vert.x installation contains your cluster manager jar.</p>\n</div>\n<div class=\"paragraph\">\n<p>If you are using Vert.x from a Maven or Gradle project just add the cluster manager jar as a dependency of your project.</p>\n</div>\n<div class=\"paragraph\">\n<p>You can also specify cluster managers programmatically if embedding Vert.x using\n<code><a href=\"../../apidocs/io/vertx/core/VertxOptions.html#setClusterManager-io.vertx.core.spi.cluster.ClusterManager-\">setClusterManager</a></code>.</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_logging\"><a class=\"anchor\" href=\"#_logging\"></a>Logging</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x logs using it&#8217;s in-built logging API. The default implementation uses the JDK (JUL) logging so no extra\nlogging dependencies are needed.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_configuring_jul_logging\"><a class=\"anchor\" href=\"#_configuring_jul_logging\"></a>Configuring JUL logging</h3>\n<div class=\"paragraph\">\n<p>A JUL logging configuration file can be specified in the normal JUL way by providing a system property called:\n<code>java.util.logging.config.file</code> with the value being your configuration file. For more information on this and\nthe structure of a JUL config file please consult the JUL logging documentation.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x also provides a slightly more convenient way to specify a configuration file without having to set a system\nproperty. Just provide a JUL config file with the name <code>vertx-default-jul-logging.properties</code> on your classpath (e.g.\ninside your fatjar) and Vert.x will use that to configure JUL.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_another_logging_framework\"><a class=\"anchor\" href=\"#_using_another_logging_framework\"></a>Using another logging framework</h3>\n<div class=\"paragraph\">\n<p>If you don&#8217;t want Vert.x to use JUL for it&#8217;s own logging you can configure it to use another logging framework, e.g.\nLog4J or SLF4J.</p>\n</div>\n<div class=\"paragraph\">\n<p>To do this you should set a system property called <code>vertx.logger-delegate-factory-class-name</code> with the name of a Java\nclass which implements the interface <code><a href=\"../../apidocs/io/vertx/core/spi/logging/LogDelegateFactory.html\">LogDelegateFactory</a></code>. We provide pre-built\nimplementations for Log4J (version 1), Log4J 2 and SLF4J with the class names\n<code>io.vertx.core.logging.Log4jLogDelegateFactory</code>, <code>io.vertx.core.logging.Log4j2LogDelegateFactory</code> and\n<code>io.vertx.core.logging.SLF4JLogDelegateFactory</code> respectively. If you want to use these implementations you should\nalso make sure the relevant Log4J or SLF4J jars are on your classpath.</p>\n</div>\n<div class=\"paragraph\">\n<p>Notice that, the provided delegate for Log4J 1 does not support parameterized message. The delegate for Log4J 2\nuses the <code>{}</code> syntax like the SLF4J delegate. JUL delegate uses the <code>{x}</code> syntax.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"netty-logging\"><a class=\"anchor\" href=\"#netty-logging\"></a>Netty logging</h3>\n<div class=\"paragraph\">\n<p>When configuring logging, you should care about configuring Netty logging as well.</p>\n</div>\n<div class=\"paragraph\">\n<p>Netty does not rely on external logging configuration (e.g system properties) and instead implements a logging\nconfiguration based on the logging libraries visible from the Netty classes:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>use <code>SLF4J</code> library if it is visible</p>\n</li>\n<li>\n<p>otherwise use <code>Log4j</code> if it is visible</p>\n</li>\n<li>\n<p>otherwise fallback <code>java.util.logging</code></p>\n</li>\n</ul>\n</div>\n<div class=\"paragraph\">\n<p>The logger implementation can be forced to a specific implementation by setting Netty&#8217;s internal logger implementation directly\non <code>io.netty.util.internal.logging.InternalLoggerFactory</code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-comment\">// Force logging to Log4j</span>\nInternalLoggerFactory.setDefaultFactory(Log4JLoggerFactory.INSTANCE);</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_troubleshooting\"><a class=\"anchor\" href=\"#_troubleshooting\"></a>Troubleshooting</h3>\n<div class=\"sect3\">\n<h4 id=\"_slf4j_warning_at_startup\"><a class=\"anchor\" href=\"#_slf4j_warning_at_startup\"></a>SLF4J warning at startup</h4>\n<div class=\"paragraph\">\n<p>If, when you start your application, you see the following message:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>SLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\".\nSLF4J: Defaulting to no-operation (NOP) logger implementation\nSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>It means that you have SLF4J-API in your classpath but no actual binding. Messages logged with SLF4J will be dropped.\nYou should add a binding to your classpath. Check <a href=\"https://www.slf4j.org/manual.html#swapping\" class=\"bare\">https://www.slf4j.org/manual.html#swapping</a> to pick a binding and configure it.</p>\n</div>\n<div class=\"paragraph\">\n<p>Be aware that Netty looks for the SLF4-API jar and uses it by default.</p>\n</div>\n</div>\n<div class=\"sect3\">\n<h4 id=\"_connection_reset_by_peer\"><a class=\"anchor\" href=\"#_connection_reset_by_peer\"></a>Connection reset by peer</h4>\n<div class=\"paragraph\">\n<p>If your logs show a bunch of:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>io.vertx.core.net.impl.ConnectionBase\nSEVERE: java.io.IOException: Connection reset by peer</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>It means that the client is resetting the HTTP connection instead of closing it. This message also indicates that you\nmay have not consumed the complete payload (the connection was cut before you were able to).</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::override/hostname-resolution.adoc[]</p>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_high_availability_and_fail_over\"><a class=\"anchor\" href=\"#_high_availability_and_fail_over\"></a>High Availability and Fail-Over</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x allows you to run your verticles with high availability (HA) support. In that case, when a vert.x\ninstance running a verticle dies abruptly, the verticle is migrated to another vertx instance. The vert.x\ninstances must be in the same cluster.</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_automatic_failover\"><a class=\"anchor\" href=\"#_automatic_failover\"></a>Automatic failover</h3>\n<div class=\"paragraph\">\n<p>When vert.x runs with <em>HA</em> enabled, if a vert.x instance where a verticle runs fails or dies, the verticle is\nredeployed automatically on another vert.x instance of the cluster. We call this <em>verticle fail-over</em>.</p>\n</div>\n<div class=\"paragraph\">\n<p>To run vert.x with the <em>HA</em> enabled, just add the <code>-ha</code> flag to the command line:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-verticle.js -ha</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Now for HA to work, you need more than one Vert.x instances in the cluster, so let&#8217;s say you have another\nVert.x instance that you have already started, for example:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-other-verticle.js -ha</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If the Vert.x instance that is running <code>my-verticle.js</code> now dies (you can test this by killing the process\nwith <code>kill -9</code>), the Vert.x instance that is running <code>my-other-verticle.js</code> will automatic deploy <code>my-verticle\n.js</code> so now that Vert.x instance is running both verticles.</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\nthe migration is only possible if the second vert.x instance has access to the verticle file (here\n<code>my-verticle.js</code>).\n</td>\n</tr>\n</table>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Important</div>\n</td>\n<td class=\"content\">\nPlease note that cleanly closing a Vert.x instance will not cause failover to occur, e.g. <code>CTRL-C</code>\nor <code>kill -SIGINT</code>\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>You can also start <em>bare</em> Vert.x instances - i.e. instances that are not initially running any verticles, they\nwill also failover for nodes in the cluster. To start a bare instance you simply do:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run -ha</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>When using the <code>-ha</code> switch you do not need to provide the <code>-cluster</code> switch, as a cluster is assumed if you\nwant HA.</p>\n</div>\n<div class=\"admonitionblock note\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Note</div>\n</td>\n<td class=\"content\">\ndepending on your cluster configuration, you may need to customize the cluster manager configuration\n(Hazelcast by default), and/or add the <code>cluster-host</code> and <code>cluster-port</code> parameters.\n</td>\n</tr>\n</table>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_ha_groups\"><a class=\"anchor\" href=\"#_ha_groups\"></a>HA groups</h3>\n<div class=\"paragraph\">\n<p>When running a Vert.x instance with HA you can also optional specify a <em>HA group</em>. A HA group denotes a\nlogical group of nodes in the cluster. Only nodes with the same HA group will failover onto one another. If\nyou don&#8217;t specify a HA group the default group <code>__DEFAULT__</code> is used.</p>\n</div>\n<div class=\"paragraph\">\n<p>To specify an HA group you use the <code>-hagroup</code> switch when running the verticle, e.g.</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-verticle.js -ha -hagroup my-group</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Let&#8217;s look at an example:</p>\n</div>\n<div class=\"paragraph\">\n<p>In a first terminal:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-verticle.js -ha -hagroup g1</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>In a second terminal, let&#8217;s run another verticle using the same group:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-other-verticle.js -ha -hagroup g1</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Finally, in a third terminal, launch another verticle using a different group:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run yet-another-verticle.js -ha -hagroup g2</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>If we kill the instance in terminal 1, it will fail over to the instance in terminal 2, not the instance in\nterminal 3 as that has a different group.</p>\n</div>\n<div class=\"paragraph\">\n<p>If we kill the instance in terminal 3, it won&#8217;t get failed over as there is no other vert.x instance in that\ngroup.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_dealing_with_network_partitions_quora\"><a class=\"anchor\" href=\"#_dealing_with_network_partitions_quora\"></a>Dealing with network partitions - Quora</h3>\n<div class=\"paragraph\">\n<p>The HA implementation also supports quora. A quorum is the minimum number of votes that a distributed\ntransaction has to obtain in order to be allowed to perform an operation in a distributed system.</p>\n</div>\n<div class=\"paragraph\">\n<p>When starting a Vert.x instance you can instruct it that it requires a <code>quorum</code> before any HA deployments will\nbe deployed. In this context, a quorum is a minimum number of nodes for a particular group in the cluster.\nTypically you chose your quorum size to <code>Q = 1 + N/2</code> where <code>N</code> is the number of nodes in the group. If there\nare less than <code>Q</code> nodes in the cluster the HA deployments will undeploy. They will redeploy again if/when a\nquorum is re-attained. By doing this you can prevent against network partitions, a.k.a. <em>split brain</em>.</p>\n</div>\n<div class=\"paragraph\">\n<p>There is more information on quora <a href=\"http://en.wikipedia.org/wiki/Quorum_(distributed_computing)\">here</a>.</p>\n</div>\n<div class=\"paragraph\">\n<p>To run vert.x instances with a quorum you specify <code>-quorum</code> on the command line, e.g.</p>\n</div>\n<div class=\"paragraph\">\n<p>In a first terminal:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-verticle.js -ha -quorum 3</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>At this point the Vert.x instance will start but not deploy the module (yet) because there is only one node\nin the cluster, not 3.</p>\n</div>\n<div class=\"paragraph\">\n<p>In a second terminal:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my-other-verticle.js -ha -quorum 3</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>At this point the Vert.x instance will start but not deploy the module (yet) because there are only two nodes\nin the cluster, not 3.</p>\n</div>\n<div class=\"paragraph\">\n<p>In a third console, you can start another instance of vert.x:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run yet-another-verticle.js -ha -quorum 3</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Yay! - we have three nodes, that&#8217;s a quorum. At this point the modules will automatically deploy on all\ninstances.</p>\n</div>\n<div class=\"paragraph\">\n<p>If we now close or kill one of the nodes the modules will automatically undeploy on the other nodes, as there\nis no longer a quorum.</p>\n</div>\n<div class=\"paragraph\">\n<p>Quora can also be used in conjunction with ha groups. In that case, quora are resolved for each particular\ngroup.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_native_transports\"><a class=\"anchor\" href=\"#_native_transports\"></a>Native transports</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x can run with <a href=\"http://netty.io/wiki/native-transports.html\">native transports</a> (when available) on BSD (OSX) and Linux:</p>\n</div>\n<div class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::override/configuring-native.adoc[]</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_native_linux_transport\"><a class=\"anchor\" href=\"#_native_linux_transport\"></a>Native Linux Transport</h3>\n<div class=\"paragraph\">\n<p>You need to add the following dependency in your classpath:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.netty<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>netty-transport-native-epoll<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.15.Final<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">classifier</span>&gt;</span>linux-x86_64<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">classifier</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Native on Linux gives you extra networking options:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>SO_REUSEPORT</code></p>\n</li>\n<li>\n<p><code>TCP_QUICKACK</code></p>\n</li>\n<li>\n<p><code>TCP_CORK</code></p>\n</li>\n<li>\n<p><code>TCP_FASTOPEN</code></p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-comment\">// Available on Linux</span>\nvertx.createHttpServer([\n<span class=\"hljs-symbol\">  tcpFastOpen:</span>fastOpen,\n<span class=\"hljs-symbol\">  tcpCork:</span>cork,\n<span class=\"hljs-symbol\">  tcpQuickAck:</span>quickAck,\n<span class=\"hljs-symbol\">  reusePort:</span>reusePort\n])</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_native_bsd_transport\"><a class=\"anchor\" href=\"#_native_bsd_transport\"></a>Native BSD Transport</h3>\n<div class=\"paragraph\">\n<p>You need to add the following dependency in your classpath:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-xml\" data-lang=\"xml\"><span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>io.netty<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>netty-transport-native-kqueue<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">version</span>&gt;</span>4.1.15.Final<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">version</span>&gt;</span>\n <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">classifier</span>&gt;</span>osx-x86_64<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">classifier</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span></code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>MacOS Sierra and above are supported.</p>\n</div>\n<div class=\"paragraph\">\n<p>Native on BSD gives you extra networking options:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>SO_REUSEPORT</code></p>\n</li>\n</ul>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-comment\">// Available on BSD</span>\nvertx.createHttpServer([\n<span class=\"hljs-symbol\">  reusePort:</span>reusePort\n])</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_domain_sockets\"><a class=\"anchor\" href=\"#_domain_sockets\"></a>Domain sockets</h3>\n<div class=\"paragraph\">\n<p>Natives provide domain sockets support for servers:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-comment\">// Only available on BSD and Linux</span>\nvertx.createNetServer().connectHandler({ so -&gt;\n  <span class=\"hljs-comment\">// Handle application</span>\n}).listen(SocketAddress.domainSocketAddress(<span class=\"hljs-string\">\"/var/tmp/myservice.sock\"</span>))</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>or for http:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\">vertx.createHttpServer().requestHandler({ req -&gt;\n  <span class=\"hljs-comment\">// Handle application</span>\n}).listen(SocketAddress.domainSocketAddress(<span class=\"hljs-string\">\"/var/tmp/myservice.sock\"</span>), { ar -&gt;\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// Bound to socket</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    ar.cause().printStackTrace()\n  }\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>As well as clients:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> netClient = vertx.createNetClient()\n\n<span class=\"hljs-comment\">// Only available on BSD and Linux</span>\n<span class=\"hljs-keyword\">def</span> addr = SocketAddress.domainSocketAddress(<span class=\"hljs-string\">\"/var/tmp/myservice.sock\"</span>)\n\n<span class=\"hljs-comment\">// Connect to the server</span>\nnetClient.connect(addr, { ar -&gt;\n  <span class=\"hljs-keyword\">if</span> (ar.succeeded()) {\n    <span class=\"hljs-comment\">// Connected</span>\n  } <span class=\"hljs-keyword\">else</span> {\n    ar.cause().printStackTrace()\n  }\n})</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>or for http:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-groovy\" data-lang=\"groovy\"><span class=\"hljs-keyword\">def</span> httpClient = vertx.createHttpClient()\n\n<span class=\"hljs-comment\">// Only available on BSD and Linux</span>\n<span class=\"hljs-keyword\">def</span> addr = SocketAddress.domainSocketAddress(<span class=\"hljs-string\">\"/var/tmp/myservice.sock\"</span>)\n\n<span class=\"hljs-comment\">// Send request to the server</span>\nhttpClient.request(HttpMethod.GET, addr, <span class=\"hljs-number\">8080</span>, <span class=\"hljs-string\">\"localhost\"</span>, <span class=\"hljs-string\">\"/\"</span>, { resp -&gt;\n  <span class=\"hljs-comment\">// Process response</span>\n}).end()</code></pre>\n</div>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_security_notes\"><a class=\"anchor\" href=\"#_security_notes\"></a>Security notes</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Vert.x is a toolkit, not an opinionated framework where we force you to do things in a certain way. This gives you\ngreat power as a developer but with that comes great responsibility.</p>\n</div>\n<div class=\"paragraph\">\n<p>As with any toolkit, it&#8217;s possible to write insecure applications, so you should always be careful when developing\nyour application especially if it&#8217;s exposed to the public (e.g. over the internet).</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_web_applications\"><a class=\"anchor\" href=\"#_web_applications\"></a>Web applications</h3>\n<div class=\"paragraph\">\n<p>If writing a web application it&#8217;s highly recommended that you use Vert.x-Web instead of Vert.x core directly for\nserving resources and handling file uploads.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x-Web normalises the path in requests to prevent malicious clients from crafting URLs to access resources\noutside of the web root.</p>\n</div>\n<div class=\"paragraph\">\n<p>Similarly for file uploads Vert.x-Web provides functionality for uploading to a known place on disk and does not rely\non the filename provided by the client in the upload which could be crafted to upload to a different place on disk.</p>\n</div>\n<div class=\"paragraph\">\n<p>Vert.x core itself does not provide such checks so it would be up to you as a developer to implement them yourself.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_clustered_event_bus_traffic\"><a class=\"anchor\" href=\"#_clustered_event_bus_traffic\"></a>Clustered event bus traffic</h3>\n<div class=\"paragraph\">\n<p>When clustering the event bus between different Vert.x nodes on a network, the traffic is sent un-encrypted across the\nwire, so do not use this if you have confidential data to send and your Vert.x nodes are not on a trusted network.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_standard_security_best_practices\"><a class=\"anchor\" href=\"#_standard_security_best_practices\"></a>Standard security best practices</h3>\n<div class=\"paragraph\">\n<p>Any service can have potentially vulnerabilities whether it&#8217;s written using Vert.x or any other toolkit so always\nfollow security best practice, especially if your service is public facing.</p>\n</div>\n<div class=\"paragraph\">\n<p>For example you should always run them in a DMZ and with an user account that has limited rights in order to limit\nthe extent of damage in case the service was compromised.</p>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_vert_x_command_line_interface_api\"><a class=\"anchor\" href=\"#_vert_x_command_line_interface_api\"></a>Vert.x Command Line Interface API</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>Unresolved directive in &lt;stdin&gt; - include::cli.adoc[]</p>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_the_vert_x_launcher\"><a class=\"anchor\" href=\"#_the_vert_x_launcher\"></a>The vert.x Launcher</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>The vert.x <code><a href=\"../../apidocs/io/vertx/core/Launcher.html\">Launcher</a></code> is used in <em>fat jar</em> as main class, and by the <code>vertx</code> command line\nutility. It executes a set of <em>commands</em> such as <em>run</em>, <em>bare</em>, <em>start</em>&#8230;&#8203;</p>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_extending_the_vert_x_launcher\"><a class=\"anchor\" href=\"#_extending_the_vert_x_launcher\"></a>Extending the vert.x Launcher</h3>\n<div class=\"paragraph\">\n<p>You can extend the set of command by implementing your own <code><a href=\"../../apidocs/io/vertx/core/spi/launcher/Command.html\">Command</a></code> (in Java only):</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\">&amp;#<span class=\"hljs-number\">64</span>;Name(<span class=\"hljs-string\">\"my-command\"</span>)\n&amp;#<span class=\"hljs-number\">64</span>;Summary(<span class=\"hljs-string\">\"A simple hello command.\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">MyCommand</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">DefaultCommand</span> </span>{\n\n <span class=\"hljs-keyword\">private</span> String name;\n\n &amp;#<span class=\"hljs-number\">64</span>;Option(longName = <span class=\"hljs-string\">\"name\"</span>, required = <span class=\"hljs-keyword\">true</span>)\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">setName</span><span class=\"hljs-params\">(String n)</span> </span>{\n   <span class=\"hljs-keyword\">this</span>.name = n;\n }\n\n &amp;#<span class=\"hljs-number\">64</span>;<span class=\"hljs-function\">Override\n <span class=\"hljs-keyword\">public</span> <span class=\"hljs-keyword\">void</span> <span class=\"hljs-title\">run</span><span class=\"hljs-params\">()</span> <span class=\"hljs-keyword\">throws</span> CLIException </span>{\n   System.out.println(<span class=\"hljs-string\">\"Hello \"</span> + name);\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>You also need an implementation of <code><a href=\"../../apidocs/io/vertx/core/spi/launcher/CommandFactory.html\">CommandFactory</a></code>:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code class=\"language-java\" data-lang=\"java\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">HelloCommandFactory</span> <span class=\"hljs-keyword\">extends</span> <span class=\"hljs-title\">DefaultCommandFactory</span>&lt;<span class=\"hljs-title\">HelloCommand</span>&gt; </span>{\n <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> <span class=\"hljs-title\">HelloCommandFactory</span><span class=\"hljs-params\">()</span> </span>{\n  <span class=\"hljs-keyword\">super</span>(HelloCommand<span class=\"hljs-class\">.<span class=\"hljs-keyword\">class</span>)</span>;\n }\n}</code></pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Then, create the <code>src/main/resources/META-INF/services/io.vertx.core.spi.launcher.CommandFactory</code> and add a line\nindicating the fully qualified name of the factory:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre>io.vertx.core.launcher.example.HelloCommandFactory</pre>\n</div>\n</div>\n<div class=\"paragraph\">\n<p>Builds the jar containing the command. Be sure to includes the SPI file\n(<code>META-INF/services/io.vertx.core.spi.launcher.CommandFactory</code>).</p>\n</div>\n<div class=\"paragraph\">\n<p>Then, place the jar containing the command into the classpath of your fat-jar (or include it inside) or in the <code>lib</code>\ndirectory of your vert.x distribution, and you would be able to execute:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx hello vert.x\njava -jar my-fat-jar.jar hello vert.x</code></pre>\n</div>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_using_the_launcher_in_fat_jars\"><a class=\"anchor\" href=\"#_using_the_launcher_in_fat_jars\"></a>Using the Launcher in fat jars</h3>\n<div class=\"paragraph\">\n<p>To use the <code><a href=\"../../apidocs/io/vertx/core/Launcher.html\">Launcher</a></code> class in a <em>fat-jar</em> just set the <code>Main-Class</code> of the <em>MANIFEST</em> to\n<code>io.vertx.core.Launcher</code>. In addition, set the <code>Main-Verticle</code> <em>MANIFEST</em> entry to the name of your main verticle.</p>\n</div>\n<div class=\"paragraph\">\n<p>By default, it executed the <code>run</code> command. However, you can configure the default command by setting the\n<code>Main-Command</code> <em>MANIFEST</em> entry. The default command is used if the <em>fat jar</em> is launched without a command.</p>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_sub_classing_the_launcher\"><a class=\"anchor\" href=\"#_sub_classing_the_launcher\"></a>Sub-classing the Launcher</h3>\n<div class=\"paragraph\">\n<p>You can also create a sub-class of <code><a href=\"../../apidocs/io/vertx/core/Launcher.html\">Launcher</a></code> to start your application. The class has been\ndesigned to be easily extensible.</p>\n</div>\n<div class=\"paragraph\">\n<p>A <code><a href=\"../../apidocs/io/vertx/core/Launcher.html\">Launcher</a></code> sub-class can:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p>customize the vert.x configuration in <code><a href=\"../../apidocs/io/vertx/core/Launcher.html#beforeStartingVertx-io.vertx.core.VertxOptions-\">beforeStartingVertx</a></code></p>\n</li>\n<li>\n<p>retrieve the vert.x instance created by the \"run\" or \"bare\" command by\noverriding <code><a href=\"../../apidocs/io/vertx/core/Launcher.html#afterStartingVertx-io.vertx.core.Vertx-\">afterStartingVertx</a></code></p>\n</li>\n<li>\n<p>configure the default verticle and command with\n<code><a href=\"../../apidocs/io/vertx/core/impl/launcher/VertxCommandLauncher.html#getMainVerticle--\">getMainVerticle</a></code> and\n<code><a href=\"../../apidocs/io/vertx/core/impl/launcher/VertxCommandLauncher.html#getDefaultCommand--\">getDefaultCommand</a></code></p>\n</li>\n<li>\n<p>add / remove commands using <code><a href=\"../../apidocs/io/vertx/core/impl/launcher/VertxCommandLauncher.html#register-java.lang.Class-\">register</a></code>\nand <code><a href=\"../../apidocs/io/vertx/core/impl/launcher/VertxCommandLauncher.html#unregister-java.lang.String-\">unregister</a></code></p>\n</li>\n</ul>\n</div>\n</div>\n<div class=\"sect2\">\n<h3 id=\"_launcher_and_exit_code\"><a class=\"anchor\" href=\"#_launcher_and_exit_code\"></a>Launcher and exit code</h3>\n<div class=\"paragraph\">\n<p>When you use the <code><a href=\"../../apidocs/io/vertx/core/Launcher.html\">Launcher</a></code> class as main class, it uses the following exit code:</p>\n</div>\n<div class=\"ulist\">\n<ul>\n<li>\n<p><code>0</code> if the process ends smoothly, or if an uncaught error is thrown</p>\n</li>\n<li>\n<p><code>1</code> for general purpose error</p>\n</li>\n<li>\n<p><code>11</code> if Vert.x cannot be initialized</p>\n</li>\n<li>\n<p><code>12</code> if a spawn process cannot be started, found or stopped. This error code is used by the <code>start</code> and\n<code>stop</code> command</p>\n</li>\n<li>\n<p><code>14</code> if the system configuration is not meeting the system requirement (shc as java not found)</p>\n</li>\n<li>\n<p><code>15</code> if the main verticle cannot be deployed</p>\n</li>\n</ul>\n</div>\n</div>\n</div>\n</div>\n<div class=\"sect1\">\n<h2 id=\"_configuring_vert_x_cache\"><a class=\"anchor\" href=\"#_configuring_vert_x_cache\"></a>Configuring Vert.x cache</h2>\n<div class=\"sectionbody\">\n<div class=\"paragraph\">\n<p>When Vert.x needs to read a file from the classpath (embedded in a fat jar, in a jar form the classpath or a file\nthat is on the classpath), it copies it to a cache directory. The reason behind this is simple: reading a file\nfrom a jar or from an input stream is blocking. So to avoid to pay the price every time, Vert.x copies the file to\nits cache directory and reads it from there every subsequent read. This behavior can be configured.</p>\n</div>\n<div class=\"paragraph\">\n<p>First, by default, Vert.x uses <code>$CWD/.vertx</code> as cache directory. It creates a unique directory inside this one to\navoid conflicts. This location can be configured by using the <code>vertx.cacheDirBase</code> system property. For instance\nif the current working directory is not writable (such as in an immutable container context), launch your\napplication with:</p>\n</div>\n<div class=\"listingblock\">\n<div class=\"content\">\n<pre class=\"highlight\"><code>vertx run my.Verticle -Dvertx.cacheDirBase=/tmp/vertx-cache\n# or\njava -jar my-fat.jar vertx.cacheDirBase=/tmp/vertx-cache</code></pre>\n</div>\n</div>\n<div class=\"admonitionblock important\">\n<table>\n<tr>\n<td class=\"icon\">\n<div class=\"title\">Important</div>\n</td>\n<td class=\"content\">\nthe directory must be <strong>writable</strong>.\n</td>\n</tr>\n</table>\n</div>\n<div class=\"paragraph\">\n<p>When you are editing resources such as HTML, CSS or JavaScript, this cache mechanism can be annoying as it serves\nonly the first version of the file (and so you won&#8217;t see your edits if you reload your page). To avoid this\nbehavior, launch your application with <code>-Dvertx.disableFileCaching=true</code>. With this setting, Vert.x still uses\nthe cache, but always refresh the version stored in the cache with the original source. So if you edit a file\nserved from the classpath and refresh your browser, Vert.x reads it from the classpath, copies it to the cache\ndirectory and serves it from there. Do not use this setting in production, it can kill your performances.</p>\n</div>\n<div class=\"paragraph\">\n<p>Finally, you can disable completely the cache by using <code>-Dvertx.disableFileCPResolving=true</code>. This setting is not\nwithout consequences. Vert.x would be unable to read any files from the classpath (only from the file system). Be\nvery careful when using this settings.</p>\n</div>\n</div>\n</div>"},"__N_SSG":true}